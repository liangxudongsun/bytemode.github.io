[{"location":"http://bytemode.github.io/","text":"","title":"Go 夜读"},{"location":"http://bytemode.github.io/reading/","text":"","title":"Go 源码阅读"},{"location":"http://bytemode.github.io/articles/","text":"","title":"分享文章"},{"location":"http://bytemode.github.io/discuss/","text":"","title":"夜读讨论"},{"location":"http://bytemode.github.io/interview/","text":"","title":"面试专题"},{"location":"http://bytemode.github.io/harvest/","text":"","title":"你的收获"},{"location":"http://bytemode.github.io/proposal/","text":"","title":"建议"},{"location":"http://bytemode.github.io/other/","text":"","title":"其他"},{"location":"http://bytemode.github.io/reading/67-2019-11-14-sql-pool-reading/","text":" Go 夜读第 67 期 Go database/sql 数据库连接池分析 本期 Go 夜读是由 POP 后端团队的邹文通给大家带来的 Go 标准包 database/sql 数据库连接池源码剖析。\n大纲  sql 连接池简介 连接池的工作原理 sql 包连接池源码分析 连接池使用 tips  Slides  https://docs.google.com/presentation/d/10kGjeHGbB0h0Cz8f58reXOyCdyWSOSKrr2160IFNla4/edit?usp=sharing  回看视频  https://www.bilibili.com/video/av75690189/ https://youtu.be/JKJ8ehtiqUM  参考资料  Go组件学习——database/sql数据库连接池你用对了吗 Go组件学习——手写连接池并没有那么简单 Chapter 8 Connection Pooling with Connector/J 彻底弄懂mysql（二）\u0026ndash;连接方式  观看视频   ","title":"第 67 期 Go database/sql 数据库连接池分析"},{"location":"http://bytemode.github.io/reading/66-2019-11-07-paper-reading-csp/","text":" Go 夜读第 66 期 Paper Reading CSP 理解顺序进程间通信 本期 Go 夜读是由 Go 夜读 SIG 核心小组成员欧长坤给大家带来的经典论文 CSP 的 Paper Reading。\nCSP 是什么？ 我们常常在讨论中提及 CSP，但鲜有人能真正说清楚 CSP 的演进历史，及其最核心的基本思想。我们已经对 Go 提供的并发原语足够熟悉了，是时候深入理解其背后的基础理论 —— 顺序进程间通信（Communicating Sequential Processes, CSP）了。本次分享我们针对 [Hoare 1978] 探讨 CSP 理论的原始设计（CSP 1978），主要围绕以下几个问题展开：\nTony Hoare 提出 CSP 的时代背景是什么？ - CSP 1978 理论到底有哪些值得我们研究的地方？ - CSP 1978 理论是否真的就是我们目前熟知的基于通道的同步方式？ - CSP 1978 理论的早期设计存在什么样的缺陷？\n大纲  CSP 1978 的诞生背景 CSP 1978 的主要内容及其结论 CSP 1978 理论中存在的设计缺陷 讨论与反思  分享 Slides  https://docs.google.com/presentation/d/1N5skL6vR9Wxk-I82AYs3dlsOsJkUAGJCsb5NGpXWpqo/edit?usp=sharing  回看视频  https://www.bilibili.com/video/av74891823/ https://youtu.be/Z8ZpWVuEx8c  参考资料  [Hoare 1978] Hoare, C. A. R. (1978). Communicating sequential processes. Communications of the ACM, 21(8), 666–677. [Ou 2019a] CSP1978 的 Go 语言实现 [Ou 2019b] 第 56 期 channel \u0026amp; select 源码分析 [Ou 2019c] 第 59 期 Real-world Go Concurrency Bugs  观看视频   ","title":"第 66 期 Paper Reading CSP 理解顺序进程间通信"},{"location":"http://bytemode.github.io/reading/65-2019-10-31-go-net/","text":" Go 夜读第 65 期 Go 原生网络模型 vs 异步 Reactor 模型 本期 Go 夜读是由 Go 夜读 SIG 核心小组邀请到潘建锋给大家分享 Go 原生网络模型 vs 异步 Reactor 模型，以下是本次分享的部分内容和 QA 。 \u0026gt;潘建锋，曾任职腾讯、现亚马逊在职。Go 语言业余爱好者，开源库 gnet 和 ants 作者。\n引子 我们都知道 Golang 基于 goroutine 构建了一个简洁而优秀的原生网络模型，让开发者能够用同步的模式去编写异步的逻辑：goroutine-per-connection 模式，极大地降低了开发者编写网络应用时的心智负担，而且借助于 Go Scheduler 对 goroutines 的高效调度，这个原生网络模型足以应对绝大部分的应用场景。\n然而，在工程性上能做到如此高的普适和兼容，给开发者提供如此简单易用的接口，其背后必然是基于非常复杂的封装，做了很多取舍，放弃了一些『极致』的概念和设计。事实上 Golang 的 netpoll 底层就是基于 epoll/kqueue/iocp 这些系统调用来做封装的，最终暴露出 goroutine-per-connection 这样的网络编程模式给开发者。\n在绝大部分应用场景下，我推荐大家还是遵循 Golang 的 best practices，以这种模式来构建自己的网络应用，然而，在某些极度需要提高性能、节省资源以及技术栈必须是原生 Go （不考虑 C/C++ 写中间层供 Go 调用）的场景下，我们可以考虑自己构建 Reactor 网络模型。那么，Reactor 模型相对原生模型有哪些优势和弊端呢？我开发了的一个基于事件驱动机制的实验性质的异步网络框架：gnet，其在性能和资源占用上都远超 Go 原生 net 包（少数特定的应用场景），通过解析这个框架和 Go 原生网络模型，我们来一一分析～～\n预备知识：epoll、非阻塞IO、IO多路复用, Linux IO模式及 select、poll、epoll详解\n分享 Slides  https://taohuawu.club/static_res/html/webslides/gnet/gnet.html  Q\u0026amp;A 总结 Q1: 为什么 gnet 会比 Go 原生的 net 包更快？ 答： Multi-Reactors 模型相较于 Go 原生模型在以下场景具有性能优势： 1. 高频创建新连接：我们从源码里可以知道 Go 模式下所有事件都是在一个 epoll 实例来管理的，接收新连接和 IO 读写；而在 Reactors 模式下，accept 新连接和 IO 读写分离，它们在各自独立的 goroutines 里用自己的 epoll 实例来管理网络事件。 2. 海量网络连接：Go net 处理网络请求的模式是 goroutine per connection，甚至是 multiple goroutines per connection，而 gnet 一般使用与机器 CPU 核心数相同的 goroutines 来处理网络请求，所以在海量网络连接的场景下 gnet 更节省系统资源，进而提高性能。 3. 时间窗口内连接总数大而活跃连接数少：这种场景下，Go 原生网络模型因为 goroutine per connection 模式，依然需要维持大量的 goroutines 去等待 IO 事件(保持 1:1 的关系)，Go scheduler 对大量 idle goroutines 的调度势必会损耗系统整体性能；而 gnet 模式下需要维护的仅仅是与 CPU 核心数相同的 goroutines，而且得益于 Reactors 模型和 epoll/kqueue，可以确保每个 goroutine 在大多数时间里都是在处理活跃连接。 4. 短连接场景：gnet 内部维护了一个内存池，在短连接这种场景下，可以大量复用内存，进一步节省资源和提高性能。\nQ2: Go netpoll 源码里的 waitRead 方法到底是起什么作用？ 答： 看源码：\n// func (fd *FD) Read(p []byte) (int, error)  for { n, err := syscall.Read(fd.Sysfd, p) if err != nil { n = 0 if err == syscall.EAGAIN \u0026amp;\u0026amp; fd.pd.pollable() { if err = fd.pd.waitRead(fd.isFile); err == nil { continue } } // On MacOS we can see EINTR here if the user  // pressed ^Z. See issue #22838.  if runtime.GOOS == \u0026#34;darwin\u0026#34; \u0026amp;\u0026amp; err == syscall.EINTR { continue } } ... // func netpollblock(pd *pollDesc, mode int32, waitio bool) bool  // need to recheck error states after setting gpp to WAIT  // this is necessary because runtime_pollUnblock/runtime_pollSetDeadline/deadlineimpl  // do the opposite: store to closing/rd/wd, membarrier, load of rg/wg  if waitio || netpollcheckerr(pd, mode) == 0 { gopark(netpollblockcommit, unsafe.Pointer(gpp), waitReasonIOWait, traceEvGoBlockNet, 5) } 通过分析 conn.Read()，我们知道这个方法是同步的，但从源码我们可以看出，Go 使用的是非阻塞 IO，所以调用 syscall.Read 的时候并不会阻塞，所以实际上它是通过 waitRead 这个方法来实现阻塞的：netFD 的 Read 操作在系统调用Read后，当遇到 syscall.EAGAIN 时，waitRead 里面的 netpollblock 会调用 gopark 将当前读这个网络描述符的 goroutine 给 park 住，直到这个网络描述符上的读事件再次发生为止，唤醒 goroutine，waitRead 调用返回，回到外层的 for 循环继续执行。conn.Write 方法和 Read 的实现原理是一样的，都是在发生syscall.EAGAIN 错误的时候将当前 goroutine 给 park 住直到 socket 再次可写为止。\nQ3: Go 的网络模型有『惊群效应』吗？ 答：没有。 我们看下源码里是怎么初始化 listener 的 epoll 示例的：\nvar serverInit sync.Once func (pd *pollDesc) init(fd *FD) error { serverInit.Do(runtime_pollServerInit) ctx, errno := runtime_pollOpen(uintptr(fd.Sysfd)) if errno != 0 { if ctx != 0 { runtime_pollUnblock(ctx) runtime_pollClose(ctx) } return syscall.Errno(errno) } pd.runtimeCtx = ctx return nil } 这里用了 sync.Once 来确保初始化一次 epoll 实例，这就表示一个 listener 只持有一个 epoll 实例来管理网络连接，既然只有一个 epoll 实例，当然就不存在『惊群效应』了。\nQ4: Multiple Reactors + Goroutine-Pool Model 这个模式，把阻塞的任务放入Goroutine-Pool，但是如果 Response 依赖于阻塞任务返回的结果(比如依赖于一个http请求结果)，这种情况Goroutine-Pool 是不是意义不大了？ gnet 提供了异步写的 API: AsyncWrite，一般都是在 goroutine pool 里处理完阻塞逻辑之后直接调用这个方法把 response 写回 socket，总之，原则就是不能阻塞 eventloop goroutine，也就是 gnet.React 方法。\nQ5:   潘少说go-net原生的网络模型相当于单reactor的模型，每一个连接一个goroutine来处理，由go的调度器实现高并发，这样应该也能利用上多核CPU的吧？为什么性能比multi-reactors的方式差这么多？ multi-reactors的主reactor万一挂了，怎么办？（类似单点故障问题） multi-reactors + goroutine pool的模式下，subreactor负责输入输出，goroutine pool负责计算，若某个任务的数据量比较大，从subreactor到goroutine pool或从goroutine pool到subreactor的数据传输成本会不会很大？   答： 问题 1 参见上面第一个我回答的问题；问题 2 说的 Reactor 单点问题的确是存在的，因为 gnet 使用的是主从 Reactors 模式，main reactor 只有一个，所以的确存在这个潜在的问题，解决办法也有：使用多 acceptors，利用 SO_REUSEPORT 参数让内核帮你做 load balancing 避免惊群；至于问题 3 ：并不存在数据传输成本，从当前 eventloop goroutine 也就是 gnet.React 方法里一般是用 closure 闭包的方式提交任务到 goroutine pool 的，是引用方式。\nQ6: goroutine pool如何把数据送回到subreactor？ 当你在独立的 goroutine 里完成你的阻塞逻辑之后得到了 response 数据，直接调用 AsyncWrite:\nfunc (c *conn) AsyncWrite(buf []byte) { if encodedBuf, err := c.loop.svr.codec.Encode(buf); err == nil { _ = c.loop.poller.Trigger(func() error { if c.opened { c.write(encodedBuf) } return nil }) } } 通过 closure 的方式，写一个唤醒事件到 epoll，同时传一个 func() error 到任务队列，在 sub reactor 的那个 goroutine 里执行这个函数，把数据写回 client。\nQ7: 在等待传回的这段时间，subreactor是不是还是得阻塞着，无法处理其他请求 不会阻塞啊，此时 React 方法已经返回了，你的阻塞逻辑是提交到 goroutine pool 里处理，处理完直接调用 AsyncWrite 异步写回去了，方式就是我上面说的，写一个唤醒事件到 epoll，在 eventloop goroutine 里执行，所以不会有同步问题。\n回看视频  https://www.bilibili.com/video/av74598921 https://youtu.be/4QurJJHuxaQ  参考资料  A Million WebSockets and Go Going Infinite, handling 1M websockets connections in Go 百万 Go TCP 连接的思考: epoll方式减少资源占用 gnet: 一个轻量级且高性能的 Golang 网络库  观看视频   ","title":"第 65 期 Go 原生网络模型 vs 异步 Reactor 模型"},{"location":"http://bytemode.github.io/reading/64-2019-10-24-go-runtime/","text":" Go 夜读第 64 期深入浅出 Golang Runtime 内容简介 本次分享将会对 go runtime 的调度，内存分配，gc 做一些细节上的讲解，同时也需要参与者对 runtime 有一些初步了解。\n内容大纲  Golang Runtime 是什么，其发展历程； 调度的实质和关键数据结构，函数； 内存分配中 mspan, mheap, mcentral, mcache 等数据结构 Golang GC 发展，Golang 三色标记实现的一些细节，元信息，写屏障，1.5 与 1.12 GC 的区别； 一点优化思路与问题排查思路； 总结及 question； 平时我看 runtime 代码的一些方式；  分享嘉宾 郝以奋，yifhao, 腾讯 NOW 直播后台开发，负责 NOW 直播 CPP+JAVA 双栈 -\u0026gt; Golang 转型：框架协同建设，业务功能定制，Go Mod 引入，服务模板，RPC 协议 Go Mod 化，服务模板，Golang 培训，文档等。\n目前 NOW 直播后台有 300 多个 Go 服务。\n分享信息 时间：2019-10-17 21:00:00 ~ 23:10:00, UTC+8 分享 Slides：https://github.com/Frank-Hust/share\n回看视频  https://www.bilibili.com/video/av73297683 https://youtu.be/oFJL8S1dwsw  Q\u0026amp;A 总结 Q: 腾讯现在用go的多吗? 多, 至少 2000 人的级别了，对go的接受度挺高的，使用人数在迅速增加，当然大部分团队还是 cpp。\nQ: 腾讯 NOW 直播 go 开发占比多少？ 我们都是从其他语言转的，cpp，java-\u0026gt;golang，一开始就写 go 的比较少。基本上学习一下，一个星期就可以开始写线上 go 服务了。目前新服务都是 go。\nQ: 线程切换的开销 线程切换大概在几微秒级别，协程切换大概在百 ns 级别。\n线程切换过程: 1. 进入系统调用 2. 调度器本身代码执行 3. 线程上下文切换: PC, SP 等寄存器，栈，线程相关的一些局部变量，还涉及一些 cache miss 的情况； 4. 退出系统调用\n协程切换不需要进入和退出系统调用, 在进行上下文切换时也更轻量, 只需要切换几个寄存器, 协程 runtime.g 结构只有 40 多个字段, 而线程的 task struct 有大概 300 个字段.\n可参考进程/线程上下文切换会用掉你多少CPU？ https://zhuanlan.zhihu.com/p/79772089\n协程究竟比线程能省多少开销？ https://zhuanlan.zhihu.com/p/80037638\nQ: 为啥是边缘触发, 而不是水平触发的方式? 因为网络操作 ready 和未 ready 对于协程来说就是状态的切换。 socket fd ready 了, 阻塞之上的协程就从 waiting 变成 runnable。 操作时 socket fd 未 ready，那协程就从 running 变成 waiting。 假如采取水平触发，如果一个协程因为某个连接读而变成 waiting 状态，这个连接有数据后，与之关联的协程就变成 ready，这个协程一直没去读数据，那水平触发一直就会 poll 出来该 fd，没必要。\nQ: 内存什么时候释放? 内存释放分两步 没有存活对象的 span 被 GC 回收, 归还到 mheap 结构中，变成 free 的 page。 sysmon 协程会扫描，超过一段时间没有再被使用的 page(1.12 机制有改变), 通过 madvise 系统调用告诉操作系统，这些 page 对应的物理内存不再需要了，可以与虚拟内存解绑，给其他分配使用。\nQ: 0.1+13+0.3ms 三个时间的意思？ GCDEBUG=gctrace=1 会打印出 gc 相关的时间，这三个分别代表，gc 开始时第一个 stw 的 wall time, 并发标记的 wall time 以及 GC 标记结束阶段 stw 的 wall time。\nQ: []byte 于 string 的黑魔法 底层数据共享，减少数据拷贝。 https://jaycechant.info/2019/golang-unsafe-cast-between-string-and-bytes/\nQ: 之前说的 netpoll，被 gopark 挂起的 G 扔哪了，怎么找到对应的 G，然后又怎么扔给对应的 M 的 runQ 的？ 并没有扔哪里去，也没放在哪个队列。 一个协程因为某个网络 fd 的操作阻塞时，会把该 fd 添加到 epoll 中，使用以下系统调用。\nint epoll_ctl(int epfd, int op, int fd, struct epoll_event *event); typedef union epoll_data { void *ptr; int fd; __uint32_t u32; __uint64_t u64; } epoll_data_t; struct epoll_event { __uint32_t events; /* Epoll events */ epoll_data_t data; /* User data variable */ }; go 在 epoll_event 中的 epoll_data_t 放了一个指针值，该指针指向一个包含 runtime.g 的结构体。 下次 epoll_wait 时，便可把该 epoll_data_t 也 poll 出来，相当于与该 fd 关联的上下文，也就可以找到阻塞其上的协程。\n不需要再放回对应的 M 的 runq 中，目前是通过 injectglist 放在全局的 runq 中。\n观看视频   ","title":"第 64 期深入浅出 Golang Runtime"},{"location":"http://bytemode.github.io/reading/63-2019-10-17-go-style-and-go-advices/","text":" Go 夜读第 63 期 Go 编码风格阅读与讨论 内容简介 本期主要是针对近期 uber-go/guide style 和 go-advices 的解读以及开发者讨论。\n内容大纲  Go CodeReview Comments Uber-go/style Go-advices  分享地址 2019-10-17 21:00:00 ~ 22:10:00, UTC+8\nhttps://zoom.us/j/6923842137\n分享 Slides https://docs.google.com/presentation/d/1MlzZJBK0Zq0VzJVC_AqSWmmlS4Of-8xY6NGZmfhKQXI/edit?usp=sharing\n进一步阅读的材料  Go CodeReviewComments uber-go/guide style go-advices  Go CodeReviewComments 翻译  Go Code Review Comments 译文（截止 2018 年 7 月 27 日）  Go 官方的建议已经涉及到非常方面：\n Gofmt Comment Sentences Contexts Copying Crypto Rand Declaring Empty Slices Doc Comments Don\u0026rsquo;t Panic Error Strings Examples Goroutine Lifetimes Handle Errors Imports Import Dot In-Band Errors Indent Error Flow Initialisms Interfaces Line Length Mixed Caps Named Result Parameters Naked Returns Package Comments Package Names Pass Values Receiver Names Receiver Type Synchronous Functions Useful Test Failures Variable Names  gofmt 不管你是用什么开发工具，都推荐一定要配置 goimports。\nContext  Context 应该在函数的第一个参数； 不要将 Context 加到结构体中，而应该加一个 ctx 参数； 不要创建自定义的 Context 类型； Context 是不可变的，所以可以将相同的 ctx 传递给调用共享相同截止日期，取消信号，凭证，父跟踪等；  虽然官方已经说明了，但是也还是有不少公司或者开源项目有自己的设计和实现。\nDeclaring Empty Slices var t[]string 比 t:= []string{} 更好\nImports 应该按系统库、内部库、第三方库分层分隔。\nIndent Error Flow if err != nil { // error handling...  return // or continue, etc. } // other codex, err := f() if err != nil { // error handling...  return } // use x... Variable Names  局部变量应该越精简越好； 不通用的或者全局变量，应该描述更清楚的命名；  Uber Go 风格指南翻译  Uber Go 风格指南 (译) by 徐旭 Uber Go 语言编程规范 by legendtkl 【重磅】Uber Go 语言代码风格指南 by Go 中国 Uber Go 语言编码规范 by TonyBai  上周刚出来，过了2天，就出现大量的翻译文章，也能够看出来 Go 语言虽然官方有 gofmt，以及 go vet 静态代码检测工具，但是也抵挡不住大家对于代码风格的热衷。 \u0026gt;也说明大家还希望将代码风格更统一，追求更好的代码。\nGo-advices  Code Concurrency Performance Modules Build Testing Tools Misc  代码方面  var foo time.Duration 比 var fooMillis int64 更好 检查 defer 中的 error 用 %+v 打印足够详细信息 小心 range map 中读取一个不存在的 key 不会 panic，建议：value, ok := map[“no_key”] 将 defer 移到顶部  Dave Cheney  Practical Go: Real world advice for writing maintainable Go programs 中文翻译版（2018 年）：https://www.flysnow.org/2018/12/04/golang-the-go-best-presentations.html  Q\u0026amp;A 总结  下划线开头 来声明 全局变量 \u0026gt;很少见，也不太适用。 为什么建议channel尽量不加buffer? \u0026gt;按需分配。 go.uber.org/atomic \u0026gt;库非常好，原子操作很方便。新增多种数据类型。 package_test 比 package 好？ \u0026gt;比较清晰，但是也有局限性，测试不了内部逻辑，类似于外部包调用。 go test 指定 -count 可以消除偶然因素导致的不稳定结果。 \u0026gt;-count=1 也可以消除 cache。 有没有认证或授权库的推荐？ \u0026gt;github 上搜索即可，一般可以根据 star 数量和活跃情况来评判。 也可以去 godoc.org 搜索，查看 imports 引入数据来评判。 https://github.com/dgrijalva/jwt-go  观看视频   ","title":"第 63 期 Go 编码风格阅读与讨论"},{"location":"http://bytemode.github.io/reading/62-2019-10-10-go-micro-part1/","text":" Go 夜读第 62 期 Go-Micro 微服务框架 Part 1 内容简介 介绍Go-Micro的设计及其重要组件\n内容大纲  什么是 Micro Micro 风格服务架构 Go-Micro 框架的设计 Go-Micro 主要的组件 Go-Micro 的插件化  分享地址 2019-10-10 21:00 ~ 22:00, UTC+8\nhttps://zoom.us/j/6923842137\n进一步阅读的材料  Micro 项目 Micro 文档 示例项目 PPT  请点击：https://github.com/developer-learning/reading-go/issues/457\nQ\u0026amp;A 总结  micro 是Restful吗？  答：go-micro并不是一个web框架，不过go-micro中有web模块可以提供restful风格服务。\n srv里面是包含client和server吗？  答：每一个服务都会有client和server，服务要能调用其它服务就需要一个client，能接收请求就需要server。\n 为什么异构service互相调用一定要经过proxy，rpc不应该是编码和transport约定好本身就支持异构调用吗？  答：micro proxy并不支持互调，它提供一个go-micro特性的代理，其它非go-micro风格的服务通过这个代理加入go-micro体系，便可以通过proxy被其它服务调用，可以是http、grpc等。\n我会在未来几天增加一篇专门介绍micro的文档在这里：micro proxy\n micro与k8s  答：这是一个常见的问题，micro会常与k8s、istio比较或联系，这是不公平的也是不合理的。主要在这么几个方面：\na) micro与k8s同时起步，或者说micro更早些，k8s的产生是基于容器技术的兴起，而容器需要管理与编排。K8s确实给大型服务集群提供了极好的运维平台，但是它在一定适度上并不是面向开发人员的工具，更多是面向运维人员的。\nb) 基于a，Micro是面向开发人员的微服务框架，如果人们用了K8s，那应该就不要用micro。\nc) 绝大部分开发者可以试问内心的需求：自己当下的服务运行需求，真的需要K8s吗？说句傲娇的话，如果不能看到micro的价值，那请不要使用micro，在K8s中使用micro，就像皇宫的大内总管，少了件最重要的东西。\n 为啥要 consul 换成 etcd  答：从4年的结合Consul经验来说，它工作得比较正常但并不尽如人意，它有太多功能我们用不到。consul更多是面向Hashicorp体系的服务，而Etcd则更纯粹是服务注册组件，是的，我们需要更纯粹的中间件。更多可以参考一篇不太细致的博文：deprecating-consul\n client 和server可以在一个go文件中吗？  答：可以，但是为什么要这么做哩？\n go-micro中如何使用链路追踪？  答：在go-micro中提供了装饰器Wrapper可以集成任何支持go语言的链路追踪插件。见：Tracing\n Go-Micro 设计初衷、目标以及未来发展方向？  答：Go-Micro 设计初衷是做一套面向开发人员的微服务框架，她要使用简单、扩展简单、管理简单。但是仍然有很长的路要走，从技术上讲，目标是要发展成Java界的Spring Cloud。\n关于未来的发展，一个技术终究是要赚钱的，Micro公司的开发与发展目标，详见与Network\n观看视频   ","title":"第 62 期 Go-Micro 微服务框架 Part 1"},{"location":"http://bytemode.github.io/reading/60-2019-09-19-ipfs-guide/","text":" Go 夜读第 60 期 IPFS 星际文件系统 背景介绍 传统的 HTTP 都是通过资源定位符来定位，在服务器关闭后，有些数据可能会永远丢失，而且如果某客户离服务器比较远，则可能延时较高。IPFS 提出使用基于内容寻址，只要拥有 hash 且网络上有人存储此数据，即可获得数据，同时自带 CDN 效果（热数据会自动分散）。\n内容简介 主要介绍一下 ipfs 的基本思想与使用，并分析源码结构以及粗略介绍相关兄弟项目（如 multiformats,filecoin 等)\n内容大纲  IPFS 的底层技术原理。 IPFS 源码概述。 超越 IPFS - 区块链存储简述。 Q\u0026amp;A。  分享地址 2019-09-19, 21:00 ~ 22:10, UTC+8\nhttps://zoom.us/j/6923842137\n进一步阅读的材料  IPFS paper 源码 PPT 预习资料  请点击：https://github.com/developer-learning/reading-go/issues/460\nQ\u0026amp;A 总结  IPFS 是如何组网的？ 答：IPFS 的底层网络库是 Libp2p，Libp2p 的路由算法是 S-KadDHT（分布式哈希表），只要能连接到网络中的几个节点，通过节点发现与交换，很容易就能进入到网络里，所以需要设置 bootstrap 节点作为连接种子。对于个人或公司想用 IPFS 组网，可以用 swarm.key 组建一个私网（需要指定一bootstrap），即可实现内部的 IPFS 网络。\n IPFS 如何实现模糊搜索？ 答：首先 IPFS 的 DAG 节点里面都是有一个 name 项，此外还有一些其他的信息可以解析，这样的话可以爬取这些元数据信息，用一些搜索引擎工具即可模糊搜索，开源实现：https://github.com/ipfs-search/ipfs-search，可以用来当做参考。\n IPFS 其他的相关资料。\n  中文资料，有一本《IPFS 原理与实践》，其次有一个 github 仓库：https://github.com/xipfs/IPFS-Internals，还有 IPFS 的各种命令解释：http://cw.hubwiz.com/card/c/ipfs/1/1/1/ 英文首先有官方文档：https://github.com/ipfs/specs，https://github.com/filecoin-project/specs，一个教程：https://flyingzumwalt.gitbooks.io/decentralized-web-primer 。\n观看视频   ","title":"第 60 期 IPFS 星际文件系统"},{"location":"http://bytemode.github.io/reading/59-2019-09-12-real-world-go-concurrency-bugs-in-paper-reading/","text":" Go 夜读第 59 期 Real-world Go Concurrency Bugs 内容简介 Go 语言鼓励其用户多使用基于消息传递的同步原语 channel，但也不排斥其用户使用基于内存共享的同步原语，提供了诸如 sync.Mutex 等互斥原语。在过去十年的时间里，Go 的实践者不断思考着这些问题：哪种同步原语更加优秀？究竟什么场景下应该使用何种同步原语？哪类同步原语能够更好的保证数据操纵的正确性？哪类同步原语对程序员的心智负担较大？何种同步原语更容易产生程序 Bug？channel 是一种反模式吗？什么类型的 Bug 能够更好的被 Bug 检测器发现？……\n[Tu et al., 2019] 调研了包括 Docker, Kubernetes, gRPC 等六款主流大型 Go 程序在演进过程中出现的 171 个与同步原语相关的 Bug，并给出了一些有趣的见解。本次分享将讨论 [Tu et al. 2019] 的研究论文。\n内容大纲  Go 常见的并发模式与论文的研究背景 论文的研究方法 Go 并发 Bug 的分类及部分主要结论  阻塞式 Bug 非阻塞式 Bug  Go 运行时死锁、数据竞争检测器对 Bug 的检测能力与算法原理（如果时间允许） 论文的结论、争议与我们的反思  分享地址 2019-09-12, 21:00 ~ 22:10, UTC+8\nhttps://zoom.us/j/6923842137\n进一步阅读的材料  [Ou, 2019a] Real-world Go Concurrency Bugs PPT  本次分享的 PPT: 这里  [Pike, 2012] Go Concurrency Patterns  Rob Pike 关于 「Go 并发模式」的 PPT  [Gerrand, 2013] Advanced Go Concurrency Patterns  Sameer Ajmani 关于 「Go 并发模式进阶」的 PPT  [Tu et al., 2019] Understanding Real-World Concurrency Bugs in Go  本次分享讨论的论文 论文作者的 PPT Bug Table 论文中对应的 GitHub 仓库：https://github.com/system-pclub/go-concurrency-bugs 与论文作者的一次面谈记录：https://www.jexia.com/en/blog/golang-error-proneness-message-passing/ Hacker News 对本文的讨论 https://news.ycombinator.com/item?id=19280927  [Utahn, 2019] Go channels are bad and you should feel bad  Reddit 对本文的讨论：https://www.reddit.com/r/golang/comments/48mnrp/go_channels_are_bad_and_you_should_feel_bad/  [Ou, 2019b] Go 夜读 第 56 期：channel \u0026amp; select 源码分析  请点击：https://github.com/developer-learning/reading-go/issues/464\nQA Q: 可以再详细说一下 lift 指标吗？\nA: 可以从两种不同的角度来思考这个指标。\n 借鉴 person 相关性系数（余弦相似性) |X·Y|/(|X|*|Y|) 借鉴 Bayes 公式 P(B|A) = P(AB)/P(A)  Lift(cause, fix) = 导致阻塞的 cause 且使用了 fix 进行修复的概率 除以 cause 的概率乘以 fix 的概率 = P(cause, fix) / (P(cause)P(fix)) = P(cause|fix)/P(cause) 接近 1 时，说明 fix 导致 cause 的概率接近 cause 自己的概率，即 P(cause|fix) 约等于 P(cause) 于是 fix 和 cause 独立 大于 1 时，说明 fix 导致 cause 的概率比 cause 自己的概率大，即 P(cause|fix) \u0026gt; P(cause) =\u0026gt; P(fix | cause) \u0026gt; P(fix)，即 cause 下 fix 的概率比 fix 本身的概率大，正相关 小于 1 时，同理，负相关   Q: 可以贴一下提到的两篇相关文献吗？\nA: 论文引用了两篇很硬核的形式化验证的论文：\n Julien Lange, Nicholas Ng, Bernardo Toninho, and Nobuko Yoshida. Fencing off go: Liveness and safety for channel-based programming. In Proceedings ofthe 44th ACMSIGPLANSymposium on Principles of Programming Languages (POPL ’17), Paris, France, January 2017.\n Julien Lange, Nicholas Ng, Bernardo Toninho, and Nobuko Yoshida. A static verification framework for message passing in go using be- havioural types. In IEEE/ACM40th International Conference on Software Engineering (ICSE ’18), Gothenburg, Sweden, June 2018.\n  Q: 作者还分享了其他语言的关于并发 Bug 的论文，比如 Rust。\nA: 地址在这里，但是思路完全一致，可以直接扫一眼结论。\nQ: 能否将 CSP 和 Actor 模型进行一下简单比较？\nA: CSP 和 Actor 的本质区别在于如何对消息传递进行建模。Actor 模型强调每个通信双方都有一个“信箱”，传递消息的发送方对将这个消息发给谁是很明确的，这种情况下 Actor 的信箱必须能够容纳不同类型的消息，而且理论上这个信箱的大小必须无穷大，很像你想要送一件礼物给别人，你会直接把礼物递给这个人，如果这个人不在，你就扔到他家的信箱里；CSP 需要有一个信道，因此对发送方而言，其实它并不知道这个消息的接收方是谁，更像是你朝大海扔了一个漂流瓶，大海这个信道根据洋流将这个漂流瓶传递给了其他正在观察监听大海的人。\nQ: 读论文的目标是什么？\nA: 我读论文主要有两个目标：1. 了解论文的研究方法，因为研究方法可能可以用在我未来的研究中；2. 了解论文的整体思路，因为论文很多，思路远比它们的结果对我未来自己的研究更重要。\nQ: 去哪儿找这类论文？\nA: 我们这次讨论的论文是我偶然在 Go 语言 GitHub 仓库的 Wiki 上看到的；一般情况下我会订阅 ArXiv，然后定期浏览新发出来的文章。\n观看视频   ","title":"第 59 期 Real-world Go Concurrency Bugs"},{"location":"http://bytemode.github.io/reading/58-2019-09-05-whats-new-in-go1.13/","text":" Go 夜读第 58 期 What\u0026rsquo;s new in Go 1.13？ 内容简介\n主要介绍了刚刚发布的 Go 1.13 Release 的内容。\n内容大纲 - Go modules - Toolchain - Runtime - CoreLibrary Improve Performance - Q\u0026amp;A\n分享地址 2019-09-05, 21:00 ~ 22:10, UTC+8\nhttps://zoom.us/j/6923842137\n进一步阅读的材料  https://golang.org/doc/go1.13 improve defer perfermance 30% goproxy.cn - 为中国 Go 语言开发者量身打造的模块代理  更多见：https://github.com/developer-learning/reading-go/issues/465\n观看视频   ","title":"第 58 期 What's new in Go 1.13？"},{"location":"http://bytemode.github.io/reading/57-2019-08-29-sync-semaphore/","text":" Go 夜读第 57 期 sync/semaphore 源码浅析 内容简介\n主要分析 golang.org/x/sync/semaphore 相关代码和 semaphore 部分使用场景。\n内容大纲 - semaphore 定义 - 源码分析 - Q\u0026amp;A\n分享地址 2019.08.29, 21:00 ~ 21:40, UTC+8\nhttps://zoom.us/j/6923842137\n进一步阅读的材料  semaphore 定义 源码 分享 PPT  补充资料  同步原语 结合 errgroup 使用 关于是否应该支持 resize 的讨论 semaphore 实现的 taskpool  更多见：https://github.com/developer-learning/reading-go/issues/456\n观看视频   ","title":"第 57 期 sync/semaphore 源码浅析"},{"location":"http://bytemode.github.io/reading/56-2019-08-22-channel-select-in-go/","text":" Go 夜读第 56 期 channel \u0026amp; select 源码分析 内容简介\nGo 语言除了提供传统的互斥量、同步组等同步原语之外，还受 CSP 理论的影响，提供了 channel 这一强有力的同步原语。本次分享将讨论 channel 及其相关的 select 语句的源码，并简要讨论 Go 语言同步原语中的性能差异与反思。\n内容大纲 - 同步原语概述 - channel/select 回顾 - channel 的结构设计 - channel 的初始化行为 - channel 的发送与接收过程及其性能优化 - channel 的回收 - select 的本质及其相关编译器优化\n分享地址 2019.08.22, 20:30 ~ 21:30, UTC+8\nhttps://zoom.us/j/6923842137\n进一步阅读的材料 [Ou, 2019] channel \u0026amp; select 源码分析 分享内容的 PPT [Ou, 2018] Go 源码研究 分享者写的一本 Go 源码分析 [Mullender and Cox, 2008] S. Mullender and R. Cox, Semaphores in Plan 9 影响 Go 语言信号量设计的一篇文章 [Drepper, 2003] U. Drepper, Futexes are Tricky 第一篇正确实现 Linux Futex 机制的文章 [Vyukov, 2014a] D. Vyukov, Go channels on steroids, January 2014 无锁式 channel 的设计提案 [Vyukov, 2014b] D. Vyukov, runtime: lock-free channels, October 2014 关于无锁式 channel 的讨论、早期实现与现状 [Hoare, 2015] C. A. R. Hoare, Communicating Sequential Processes. May 18, 2015 有关 CSP 理论的一切，与早期 1978 年的版本相比更为完善和严谨 [Creager, 2016] D. Creager, An oversimplified history of CSP, 2016 CSP 理论的极简史\n更多见：https://github.com/developer-learning/reading-go/issues/450\n本次分享的 Q\u0026amp;A 以及几个未在分享过程中进行回答的问题： Q: buffer 队列的顺序是先进后出吗？\nA: 不对，channel 中的 ring buffer 是一种先进先出 FIFO 的结构。\nQ: channel 也是基于共享内存实现的吗？\nA: 没错，从实现上来看，具体而言，channel 是基于对 buffer 这一共享内存的实体来实现的消息通信，每次对所共享内存区域的操作都需要使用互斥锁（个别 fast path 除外）。\nQ: 创建 channel 所申请的内存，在其被 close 后何时才会释放内存？\nA: 需要等待垃圾回收器的配合（GC）。举例来说，对于某个 channel 而言，所通信双方的 goroutine 均已进入 dead 状态，则垃圾回收器会将 channel 创建时申请的内存回收到待回收的内存池，在当下一次用户态代码申请内存时候，会按需对内存进行清理（内存分配器的工作原理）；由此可见：如果我们能够确信某个 channel 不会使其通信的 goroutine 发生阻塞，则不必将其关闭，因为垃圾回收器会帮我们进行处理。\nQ: 请问是否可以分享一下带中文注释的代码？\nA: 带中文注释的代码可以在这个仓库的 gosrc 文件夹下看到。\nQ: 能详细说明一下使用 channel 发送指针产生数据竞争的情况吗？\nA: 这个其实很好理解，若指针作为 channel 发送对象的数据，指针本身会被 channel 拷贝，但指针指向的数据本身并没有被拷贝，这时若两个 goroutine 对该数据进行读写，仍然会发生数据竞争；请参考此例 （使用 -race 选项来检测竞争情况）。因此，除非在明确理解代码不会发生竞争的情况下，一般不推荐向 channel 发送指针数据。\nQ: 分享的 PPT 的地址在哪儿？\nA: 链接在这里，此 PPT 允许评论，若发现任何错误，非常感谢能够指出其错误，以免误导其他读者。\nQ: 请问分享的视频链接是什么？\nA: 有两个渠道，YouTube, bilibili，bilibili 中视频声画不同步，可使用 B 站的播放器进行调整，或推荐使用 YouTube 观看。\nQ: Go 语言中所有类型都是不安全的吗？\nA: 这个问题不太完整，提问者应该是想说 Go 中的所有类型都不是并发安全的。这个观点不对，sync.Map 就是一个并发安全的类型（当然如果你不考虑标准库的话，那么内建类型中，channel 这个类型也是并发安全的类型）。\nQ: 如果 channel 发送的结构体太大，会不会有内存消耗过大的问题？\nA: 取决于你结构体本身的大小以及你所申请的 buffer 的大小。通常在创建一个 buffered channel 时，该 channel 消耗的内存就已经确定了，如果内存消耗太大，则会触发运行时错误。我们更应该关注的其实是使用 channel 发送大小较大的结构体产生的性能问题，因为消息发送过程中产生的内存拷贝其实是一件非常耗性能的操作。\nQ: select{} 的某个 case 发生阻塞则其他 case 也不会得到执行吗？\nA: 对的。包含多个 case 的 select 是随机触发的，且一次只有一个 case 得到执行。极端情况下，如果其中一个 case 发生永久阻塞，则另一个 case 永远不会得到执行。\nQ: select 中使用的 heap sort 如何保证每个 case 得到均等的执行概率呢？是否可能会存在一个 case 永远不会被执行到？\nA: 理论上确实是这样。但是代码里生成随机数的方法保证了是均匀分布，也就是说一个区间内的随机数，某个数一直不出现的概率是零，而且还可以考虑伪随机数的周期性，所以所有的 case 一定会被选择到，关于随机数生成的具体方法，参见 runtime.fastrand 函数。\nQ: lockorder 的作用是什么？具体锁是指锁什么？\nA: lockorder 是根据 pollorder 和 channel 内存地址的顺序进行堆排序得到的。 pollorder 是根据 random shuffle 算法得到的，而 channel 的内存地址其实是内存分配器决定的，考虑到用户态代码的随机性，因此堆排序得到的 lockorder 的结果也可以认为是随机的。lockorder 会按照其排序得到的锁的顺序，依次对不同的 channel 上锁，保护其 channel 不被操作。\nQ: buffer 较大的情况下为什么没有使用链表结构？\nA: 这个应该是考虑了缓存的局部性原理，数组具有天然的连续内存，如果 channel 在频繁的进行通信，使用数组自然能使用 CPU 缓存局部性的优势提高性能。\nQ: chansend 中的 fast path 是直接访问 qcount 的，为什么 chanrecv 中却使用了 atomic load 来读取 qcount 和 closed 字段呢？\nA: 这个这两个 fast path 其实有炫技的成分太高了，我们需要先理解这两个 fast path 才能理解为什么这里一个需要 atomic 操作而另一个不需要。\n首先，他们是针对 select 语句中非阻塞 channel 操作的的一种优化，也就是说要求不在 channel 上发生阻塞（能失败则立刻失败）。这时候我们要考虑关于 channel 的这样两个事实，如果 channel 没有被 close：\n 那么不能进行发送的条件只可能是： unbuffered channel 没有接收方（ dataqsiz 为空且接受队列为空时），要么 buffered channel 缓存已满（dataqsiz != 0 \u0026amp;\u0026amp; qcount == dataqsize） 那么不能进行接受的条件只可能是：unbuffered channel 没有发送方（ dataqsiz 为空且发送队列为空），要么 buffered channel 缓存为空（dataqsiz != 0 \u0026amp;\u0026amp; qcount == 0）  理解是否需要 atomic 操作的关键在于：atomic 操作保证了代码的内存顺序，是否发生指令重排。\n由于 channel 只能由未关闭状态转换为关闭状态，因此在 !block 的异步操作中，\n第一种情况下，channel 未关闭和 channel 不能进行发送之间的指令重排是能够保证代码的正确性的，因为：在不发生重排时，「不能进行发送」同样适用于 channel 已经 close。如果 closed 的操作被重排到不能进行发送之后，依然隐含着在判断「不能进行发送」这个条件时候 channel 仍然是未 closed 的。\n但第二种情况中，如果「不能进行接收」和 channel 未关闭发生重排，我们无法保证在观察 channel 未关闭之后，得到的 「不能进行接收」是 channel 尚未关闭得到的结果，这时原本应该得到「已关闭且 buf 空」的结论（chanrecv 应该返回 true, false），却得到了「未关闭且 buf 空」（返回值 false, false），从而报告错误的状态。因此必须使此处的 qcount 和 closed 的读取操作的顺序通过原子操作得到顺序保障。\n参考 1 首次引入 2 性能提升\nQ: 听说 cgo 性能不太好，是真的吗？\nA: 是的，至少我的经验的结论是 cgo 性能非常差。因为每次进入一个 cgo 调用相当于进入 system call，这时 goroutine 会被抢占，从而导致的结果就是可能会很久之后才被重新调度，如果此时我们需要一个密集的 cgo 调用循环，则性能会非常差。\nQ: 看到你即写 C++ 也研究 Go 源码，还做深度学习，能不能分享以下学习的经验？\nA: 老实说我已经很久没（正儿八经）写 C++ （的项目）了，写 C++ 那还是我本科时候的事情，那个时候对 C++ 的理解还是很流畅的，但现在已经感觉 C++ 对于我编程的心智负担太高了，在编写逻辑之外还需要考虑很多与之不相关的语言逻辑，大部分时间其实浪费在这上面了，时间稍长就容易忘记一些特性。加上我后来学了 Go ，就更不想用 C++ 了。另外，我读硕士的时候主要在研究机器学习，主要就是在写 python 脚本。所以我暂时也没什么比较系统的经验，如果非要回答的话，我的一个经验就是当（读源码）遇到问题之后硬着头皮走下去，当积累到一定程度之后在回过头去审视这些问题，就会发现一切都理所当然。\nQ: 你是怎么读 Go 源码的？\nA: 最开始的时，我选择了一个特定的版本，将想看的源码做了一个拷贝（主要是运行时的代码，刨去了 test、cgo、架构特定等代码），而后每当 Go 更新一个版本时，都用 GitHub Pull request 的 diff 功能，去看那些我关心的代码都发生了哪些改变。当需要我自身拷贝的代码时，其实会发现工作量并不是很大。刚接触 Go 源码的时候其实也是一脸懵，当时也并没有太多 Go 的编码经验，甚至连官方注释都看不太明白，后来硬着头皮看了一段时间，就慢慢的适应了。\nQ: 有没有什么比较好的英文的（Go 相关的）资料推荐？\nA: 其实我订阅的 Go 的信息并不多，主要原因还是信息量太多，平时太忙应付不过来，所以只订阅了几个比较知名的博客，比如 www.ardanlabs.com/blog, dave.cheney.net 和一些 medium 上比较大众的跟 Go 有关的 channel；我倒是经常在地铁或睡觉前听一个叫做 Go Time 的 Podcast，这个 Podcast 是有 Go 团队的成员参与的，很值得一听。另外再推荐一些与 Go 不是强相关的技术类书籍，参见 书籍推荐。\n观看视频   ","title":"第 56 期 channel \u0026 select 源码分析"},{"location":"http://bytemode.github.io/reading/55-2019-08-15-go-webassembly-guide/","text":" Go 夜读第 55 期 Go\u0026amp;WebAssembly 简介 WebAssembly 简介 WebAssembly 是一种新兴的网页虚拟机标准，它的设计目标包括：高可移植性、高安全性、高效率（包括载入效率和运行效率）、尽可能小的程序体积。\n根据 Ending 定律：⼀切可被编译为 WebAssembly 的，终将被编译为 WebAssembly。\n本次分享 Go\u0026amp;WebAssembly 相关的用法。\n分享时间 2019-08-15 21:00:00\n分享平台 zoom 在线直播 - https://zoom.us/j/6923842137\n更多讨论 FelixSeptem：补充一下 go 官方给的 wiki https://github.com/golang/go/wiki/WebAssembly 以及 WebAssembly 官网 https://webassembly.org/ 个人比较倾向于对于 https://github.com/gopherjs/gopherjs 来比较理解，相对于 go-\u0026gt;js (包括 react 等等) 的方案，WebAssembly 带来的异同是什么？\nchai2010 ：@FelixSeptem wasm 和 gopherjs 最大的差异：wasm 是官方支持，同时 wasm 是国际标准是其它语言认可的中间格式。\n以前虽然很多工具输出 js，那是因为没有 wasm 可以选择。 现在有了 wasm，大家肯定只支持 wasm 而逐渐弱化 js 的支持。 毕竟 wasm 虚拟机实现比 v8 简单多了，性能又可以秒杀 js。\nwasm 最大的潜力是在浏览器之外，甚至可以想象成一个轻量化的 Docker 环境。 我觉得这个才是 wasm 真正有意思的地方，wasm 对于 js 完全属于降维打击。\nchangkun：还没有在生产环境使用过 wasm。从给的马里奥的例子来看，go wasm 本质上是分发由 Go 编译好 .wasm，而 Go 端的本质就是提供了一些能够解释为 wasm 的 utils。不太清楚会不会在分享中提及这一本质。\n长远来看，这个 .wasm 文件在特性支持的情况下最终会包含完整的 Go 运行时， 但 go wasm 并没有明确在 web 场景下为什么一定需要它，当然不可否认它的确为兼容并移植 Go 代码来发展 web 应用带来了便捷，但前提是我们必须有足够多基础设施是基于 Go 的，但游戏并没有，非常希望看到一些能够说服用 Go 写 wasm 而不是其他语言（C/C++ 有着丰富的图形资产，而 Go 在这方面的积累为 0，甚至连马里奥的例子都是依赖一个 cgo 对 c sdl2 renderer 的封装）编译 wasm 的论点。\n参考资料  《Go\u0026amp;WebAssembly 简介》 PPT  《WebAssembly 标准入门》 图书  观看视频   ","title":"第 55 期 Go\u0026WebAssembly 简介"},{"location":"http://bytemode.github.io/reading/54-2019-08-14-tidb-sql-tools/","text":" Go 夜读第 54 期 TiDB SQL 兼容性测试工具简介 本次分享包含两方面内容：\n通过 MySQL yacc 文件生成 SQL Cases，并用于 TiDB 的兼容性测试的原理讲解。 TiDB Parser 兼容性社区活动介绍，手把手的演示如何参与本次社区活动。\n(彩蛋：Parser Working Group 成立了，有兴趣的小伙伴可以看视频然后扫描加入。)\n分享时间 2019-08-14 21:00:00\n分享平台 zoom 在线直播 - https://zoom.us/j/6923842137\n参考资料  三十分钟成为 Contributor | 提升 TiDB Parser 对 MySQL 8.0 语法的兼容性  观看视频   ","title":"第 54 期 Go 夜读之 TiDB SQL 兼容性测试工具简介"},{"location":"http://bytemode.github.io/reading/53-2019-08-01-build-in-delete-from-map-in-go/","text":" Go 夜读第 53 期 delete from map in go 突然有一个需求要删除 map 中的一些过滤数据。 \u0026gt;由此查阅了一些资料，然后促成此次分享。\nPPT： build-in func delete from map in go.pptx\n分享时间 2019-08-01 21:00:00\n分享平台 zoom 在线直播 - https://zoom.us/j/6923842137\n参考资料  https://stackoverflow.com/questions/1736014/delete-mapkey-in-go https://blog.cyeam.com/json/2017/11/02/go-map-delete https://blog.golang.org/go-maps-in-action https://gobyexample.com/maps https://stackoverflow.com/questions/23229975/is-it-safe-to-remove-selected-keys-from-map-within-a-range-loop https://www.cnblogs.com/qcrao-2018/p/10903807.html https://appdividend.com/2019/05/12/golang-maps-tutorial-with-examples-maps-in-go-explained/ https://www.jianshu.com/p/92e9efec8688 https://www.reddit.com/r/golang/comments/5tfx7i/why_delete_doesnt_return_a_bool/ https://www.liwenzhou.com/posts/Go/08_map/ https://github.com/EDDYCJY/blog/tree/master/map  观看视频   ","title":"第 53 期 Go 夜读之 build in func delete from map"},{"location":"http://bytemode.github.io/reading/52-2019-07-25-httprouter-guide/","text":" httprouter 简介 详细内容，可以查看 https://cch123.github.io/httprouter/\n观看视频   ","title":"第 52 期 Go 夜读之 httprouter 简介"},{"location":"http://bytemode.github.io/reading/51-2019-07-18-sync-errgroup/","text":" golang.org/x/sync/errgroup errgroup 唯一的坑是for循环里千万别忘了 i, x := i, x，以前用 waitgroup 的时候都是 go func 手动给闭包传参解决这个问题的，errgroup 的.Go没法这么干，犯了好几次错才改过来\u0026rdquo;\n观看视频   ","title":"第 51 期 Go 夜读之 sync/errgroup 源码阅读"},{"location":"http://bytemode.github.io/reading/50-2019-06-27-goland-practrice/","text":" GoLand Tips \u0026amp; Tricks 问答 21:01:08 From Shengyou Fan : 全程英文+中文翻译 21:04:11 From Hao : Shengyou , r u come from TW ? 21:04:50 From Shengyou Fan : Yes, I’m from TW 21:10:04 From lucas : ctrl + tab 对应 mac 是？ 21:10:12 From mai yang : presentation assistant 21:10:26 From Shengyou Fan : 也是 ctrl + tab 21:14:26 From Dominic : 这种 example 自己在document中定义的话 是代码块吗 21:27:37 From lucas : 有什么办法可以在terminal中快速打开一个文件吗？ 21:27:46 From 江金 饶 to mai yang (Privately) : open xxx 21:27:50 From mai yang to 江金 饶 (Privately) : opne xxx 21:27:59 From mai yang : open xxx 21:28:01 From Dominic : open on mac or start on win 21:28:03 From Hao : Mac, open file 21:28:08 From Zhongxuan的 iPhone : Open . 21:28:16 From lucas : 在ide中打开 21:28:33 From Hao : \u0026hellip;\u0026hellip;. 21:28:48 From mrj : 你把对应的文件关联到ide就行了 21:29:05 From lucas : ide中的terminal 应该是可以做到的 21:29:08 From lucas : 但是我没找到 21:29:47 From mai yang : 新版本 2019.1.3 好像不能 goland . 打开某个项目了，你们的可以吗？ 21:32:57 From kevin : 双击shift还是挺不错的 21:33:04 From Kevin Bai : command + shift + A 👍 21:34:21 From mai yang : 有快捷键冲突也是很麻烦。。。 21:35:47 From mai yang : 这是全新的一种开发方式。 21:40:17 From kevin : 这个就牛逼了 21:40:24 From zhaohe : 6666 21:40:29 From bruce : 一直都用 21:40:34 From tangyinpeng : 我原来不会用goland 21:40:45 From bruce : 我一直在用这个功能 21:40:48 From kevin : 还可以自动生成 21:42:20 From Dominic : 以前玩android studio的时候模板代码玩的很溜 超级提升生产力 →_→ 21:42:26 From mrj : 可视化编程 21:43:26 From mrj : ctrl+t 21:44:37 From kevin : 看来工具还是用的不够6啊 21:46:14 From Zhongxuan的 iPhone : 跟我用mac不太一样，有点难受 21:49:15 From tangyinpeng : 做笔记啊，兄弟们 21:49:42 From kevin : 看下今晚收获少 21:49:49 From kevin : 收获多少 21:50:17 From f430 w : 掌握快捷键效率杠杠的 21:53:47 From razil : alt+enter 大法好 21:55:34 From f430 w : 当然了ide快捷键用多了，不利于白板徒手写code，哈哈 21:55:51 From razil : 面试凉凉 21:56:23 From Kevin Bai : 想太多了，先听课吧 21:58:58 From tangyinpeng : 重构快捷键是哪个来着，对不住，刚刚分心了 21:59:15 From Dominic : ctrl alt shift T 21:59:19 From tangyinpeng : tk 21:59:22 From mai yang : ctrl+t 22:06:11 From bruce : 这个req太简单 22:06:15 From bruce : 用过。 22:06:45 From Kevin Bai : 下一步搞不好就有惊艳 22:07:03 From bruce : 嗯 22:08:28 From Dominic : 咦 单元测试可以用这个玩吗 22:12:58 From Kevin Bai : 最近刚知道这个share 22:16:40 From mai yang : Share 怎么用呢？ 22:22:09 From Kevin Bai : 会在 .idea 下生成一个 run configuration ，然后可以把share的功能传到git上 22:33:38 From mrj : 这个吊 22:45:30 From 陳明進 : 直接run test with cpu profile真的是有點屌 22:53:29 From mai yang : 厉害！ 22:54:13 From 陳明進 : 這跟chrome devTool學的吧\u0026hellip;. 22:56:38 From Dominic : thank u for this great presentation 22:56:53 From Kevin Bai : 多线程调试有什么建议 ？ 22:58:14 From Eiger : 我想问下go项目包管理最推荐的是用哪个啊 22:58:26 From Dominic : go module 22:58:28 From yongping zhao : 肯定mod呀 22:58:52 From Eiger : 但是国内经常要手动获取库版本再replace 22:59:13 From Dominic : goproxy 23:00:00 From Eiger : 有免费的代理吗还是需要自己在国外搭？个人使用 23:00:22 From Dominic : goproxy.io 开源的 23:00:24 From yongping zhao : go proxy。。搜这个关键字。 23:01:26 From yongping zhao : 多线程调试有什么建议 ？ 23:02:00 From mai yang : https://blog.jetbrains.com/cn 23:02:20 From mrj : ctrl+e 23:02:23 From mai yang : Double+shift\u2028alter+enter 23:04:52 From Kevin Bai : 👍 23:05:19 From mai yang : Productivity Guide 这个很好。 23:05:44 From mrj : windwos 的 terminal 不太好用 23:06:04 From Dominic : 我一般替换成 git bash 23:06:12 From Lewis : +1 23:06:57 From Hao : hi florin , could you please show us the go mod difference between cmd and goland IDE? 23:07:58 From Kevin Bai : 是 23:07:59 From Kevin Bai : debug 23:09:12 From Dominic : 👍 23:10:57 From Lewis : double Ctrl 具体怎么用的？一直没搞懂 23:11:13 From mrj : goland有什么内置的lint工具吗 23:11:17 From mai yang : 连续按两次 shift 23:11:25 From mai yang : Double shift 不是double ctrl 23:12:09 From Lewis : run everywhere 就是double ctrl 23:12:11 From Eiger : cmder 23:13:11 From mrj : wondful 23:13:14 From mai yang : 哦 23:13:25 From Lewis : 好像是去年底更新出来的吧 23:17:09 From Dominic : wow 23:17:17 From mai yang : 这个厉害了~ 23:17:22 From mrj : 牛逼 23:17:28 From yongping zhao : 666 23:17:51 From g : 666 23:18:42 From mrj : 还能直接下载 23:19:02 From lidedongsn : 人性化 23:19:06 From tianyi wang : 这个真不知道 23:19:33 From Lewis : download go sdk 我之前试了几次都加载不出来 23:19:51 From Lewis : 是国内网络环境都问题吗 23:19:52 From mrj : 可能是从golang.org download的 23:20:18 From tianyi wang : ha介绍代理了 23:21:50 From mrj : 私有仓库 这个问题之前还真遇到了 23:22:07 From mrj : goland 一直提示go list -m 找不到包 23:22:22 From Lewis : vgo设置里面的proxy历史记录可以删除吗？写错过一次，强迫症表示看着受不了 23:23:22 From tianyi wang : 对我也遇到过，go list -m一直到找不到goole.org的那几个包 23:24:55 From Kevin Bai : 这个实用 23:25:16 From Dominic : 类似 workspace 的概念 23:25:41 From bruce : 这个实用 23:25:51 From Lewis : 之前这样弄搞得改错项目文件过😂 23:27:13 From bruce : hehe 23:28:17 From mrj : 如果这个能图形化就好了 23:31:27 From mai yang : 运行出来的怎么结束掉呢？ 23:31:41 From mai yang : double ctrl 之后的进程，怎么中断掉？ 23:32:18 From mai yang : 必须点击终止键？不能快捷键 ctrl+c? 23:32:48 From mai yang : File watchers : golint goimports 23:33:02 From mai yang : gofmt 23:33:46 From Dominic : watcher 用多了 cpu 会爆吧😂 23:44:15 From tianyi wang : 有做rust的IDE的计划吗\n观看视频   ","title":"第 50 期 Go 夜读之 GoLand Tips \u0026 Tricks"},{"location":"http://bytemode.github.io/reading/49-2019-06-26-tidb-transaction-reading/","text":" TiDB Transaction 内容介绍 本次分享主要讲 TiDB 的事务执行过程和一些异常处理，涉及 TiDB 的 session 和 tikv 部分模块。\nPDF: Source code reading of TiDB Transaction .pdf\n推荐阅读  TiDB 源码阅读系列文章（十九）tikv-client（下） 三篇文章了解 TiDB 技术内幕 - 说存储 Transaction in TiDB Coprocessor in TiKV  视频回看  TiDB 源码学习之 Executor - YouTube TiDB 源码学习之 Executor - Bilibili  问题 21:17:34 From zq : 分享妹子用的是什么IDE 21:17:44 From mrj : goland 21:17:45 From Pure White : 左上角，goland 21:17:45 From tangyinpeng : goland 21:17:46 From Heng Long : goland 21:17:57 From zq : goland现在做得这么好看啦 21:18:05 From Heng Long : Meterial theme 21:18:07 From mrj : 下来主题 21:18:22 From lk : 有什么比较不错的主题吗？ 21:18:31 From Pure White : darcula 21:18:35 From mrj : 默认的就挺好的 21:20:04 From mai yang : 明天晚上将由 GoLand 布道师给我们分享 GoLand 的使用及技巧实践分享。 21:28:23 From HAITAO的 iPhone : 点查不带timestamp，直接读最新稳定版本么？ 21:28:32 From Wei Yao : 对 21:28:52 From liber xue : 双击shift 直接search 21:28:55 From Wei Yao : 最新 commited 版本 21:35:50 From HAITAO的 iPhone : 点查，实际会默认给一个当前最新的timestamp,根据这个ts，kv返回对应的版本值?还是不带任何ts，发给kv ？ 21:36:29 From Wei Yao : 用 maxTs 21:50:04 From openinx : A very nice talk. 22:05:22 From kzl : 获取完成之后，region扩容了，数据迁移走了怎么办？ 22:06:16 From jeff : 是说 region 分裂了吧。 22:06:33 From kzl : 对的 22:08:46 From ruiayLin : region信息就会过期 22:11:05 From jeff : 那提交的时候会重试吧 22:11:39 From hezhiyong : tidb不断缓存region 的信息会不会占用很大的内存 22:13:23 From jeff : 唔，这里应该只缓冲曾经用到的 region ，并不是集群中所有 region 22:13:52 From jeff : s/ 缓冲 / 缓存 /g 22:14:44 From jeff : 貌似讲到刚才数据 region 分裂后的场景了。 22:14:56 From Wei Yao : 会重试 22:26:54 From fj : 大神 tidb的事物隔离级别 能介绍下吗？- ̗̀(๑ᵔ⌔ᵔ๑) 22:29:35 From Tengjin Xie : snapshot isolation? 22:31:48 From Wei Yao : 比 mysql 的 rr 稍微高一点 22:33:41 From fj : 刚才 讲的tidb的隔离级别是？ 22:34:03 From Wei Yao : 你可以认为是 可重复读 22:34:11 From Wei Yao : 其实这是快照隔离级别\n观看视频   ","title":"第 49 期 TiDB 源码阅读之 Transaction"},{"location":"http://bytemode.github.io/reading/48-2019-06-19-tidb-compiler-reading/","text":" TiDB Compiler 内容介绍 本次分享主要讲 TiDB 的优化器框架以及具体的 SQL 执行优化原理 。主要涉及 TiDB 的 planner 模块。欢迎大家参加！\nPPT: TiDB Compiler.pdf\n推荐阅读  TiDB 源码阅读系列文章（七）基于规则的优化 TiDB 源码阅读系列文章（八）基于代价的优化 TiDB 源码阅读系列文章（二十一）基于规则的优化 II  视频回看  TiDB 源码学习之 Executor - YouTube TiDB 源码学习之 Executor - Bilibili  问题 22:13:46 From mai yang : rule 怎么对照文档帮助理解呢？ 22:16:31 From dqyuan : 怎么快速找到代码对应的pr？ 22:18:43 From Wei Yao : git blame 22:23:04 From kzl : Order by 是会下推到tikv吗？ 22:25:02 From Wei Yao : 除非 order by 带了 limit，要不然推下去没意义 22:25:25 From Wei Yao : 有一些情况，如果是 order by 一个索引，那就直接消除掉这个 排序操作了 22:26:07 From zhao : 有意义吧，推了之后 tidb端可以直接stream merge，不知道实现了没有 22:27:38 From Wei Yao : 是可以 stream merge, 但是现在 tidb 还没实现这个，因为优先级不是太高 22:30:42 From Wei Yao : stream merge 主要是可以节省一些内存，避免 order by 太多导致 tidb oom 22:30:56 From Heng Long : 嗯，会让 tikv 的压力变大 22:34:28 From hezhiyong : limit offset 分页性能不好 22:34:53 From hezhiyong : 有好变通改写方法没 22:35:52 From hezhiyong : limit offset 会有下推到tikv么 22:36:19 From Wei Yao : limit offset 没办法的，这个是全局的 offset 22:36:40 From Wei Yao : tikv 并不知道自己的 offset 在全局的 offset 是多少 22:37:05 From Wei Yao : 这个其他数据库其实也一样 22:37:37 From hezhiyong : 那就是这个数据就是要全拿到tidb层在来过滤 22:37:38 From hezhiyong : 是吧 22:39:27 From Hao’s iPad : 喝口水吧 22:45:35 From zhao : 这个skyline prune有相关的资料吗 22:45:41 From zhao : paper之类的 22:47:09 From Wei Yao : 我记得暂时还没有 public 22:47:20 From Wei Yao : skyline pruning 就是消除一些路径 23:04:22 From mai yang : 怎么快速找到代码对应的pr？git blame\u2029这个可以演示一下吗？ 23:06:42 From tangenta : github 上面看文件的时候有个选项是 blame，那里应该比较清晰 23:09:44 From mai yang : github 上面看文件的时候有个选项是 blame，那里应该比较清晰\u2028——\u2028这个不错，看到了。\n观看视频   ","title":"第 48 期 TiDB 源码阅读之 Compiler"},{"location":"http://bytemode.github.io/reading/47-2019-06-12-tidb-exector-reading/","text":" TiDB Executor 内容介绍 本次分享主要讲 TiDB 中 insert/update/delete/select, 以及 DDL 等是如何执行的，以及涉及到相关模块。大概会涉及以下模块：\n executor distsql ddl  PPT: TiDB Executor 源码阅读.pdf\n推荐阅读  Select 语句概览 INSERT 语句详解 DDL 源码解析  视频回看  TiDB 源码学习之 Executor - YouTube TiDB 源码学习之 Executor - Bilibili  PPT: https://github.com/developer-learning/reading-go/files/3281080/TiDB.Executor.pdf\n问题  表的信息是怎么存的呢\u2028 id的生成规则是什么\u2028 如果索引里面不保存handle_id，那怎么根据索引找到这行数据呢\u2028 索引字段很大会不会有问题，作为id的一部分的话 单条6m的限制是怎么计算出来的？还是压力测出来的？ ddl时，job放到tikv的队列，tikv是分布式的，job具体是放到哪个tikv上的呢？ 并行ddl 如何跑 tikv整体上可以看成一个kv store region这部分概念可以配合hbase去看看能更好的理解 难道own tidb server要遍历所有的tikv server上的queue，去取ddl的job？ tidb 的统计信息也是放一个表里面，每次parse 都会去拿这个信息，这样的话请求到一个region,这个表是不是很容易成为热点  观看视频   ","title":"第 47 期 TiDB 源码阅读之 Executor"},{"location":"http://bytemode.github.io/reading/46-2019-06-05-tidb-overview-reading/","text":" TiDB Source Code Overview 视频回看  TiDB 源码学习之 Source Code Overview - YouTube TiDB 源码学习之 Source Code Overview - Bilibili  意见反馈  【Go夜读】《TiDB Source Code Overview》反馈  chat 答疑 20:54:52 From mai yang : 大家好，欢迎大家前来参加 Go 夜读\u0026amp;TiDB 源码学习！ 21:22:34 From nange : Session 怎么初始化的？ 21:22:46 From ccong deng : 每个连接都是跟一个session对象对应么？ 21:22:48 From jeffery : session主要包含什么？ 21:22:59 From jeffery : 譬如： 21:23:01 From Wei Yao : 对，一个链接一个 session 21:23:09 From Wei Yao : 具体包含什么，可以大家自己去看了 21:23:17 From Wei Yao : 这个线上不可能所有都讲的 21:23:25 From jeffery : 好的，谢谢了 21:31:00 From Wei Yao : 大家如果对语法分析，词法分析感兴趣，可以去看看 yacc 跟 lex 21:31:10 From hezhiyong : parser 这一层不是使用mysql的parser吗 21:31:17 From Wei Yao : 不，我们自己写的 21:31:56 From hezhiyong : mysql 的语法解析是在那一步用到了？ 21:32:01 From tianyi wang : select coalesce（）中coalesce是在fields里面吗 21:32:10 From Wei Yao : 我们的语法解析就是兼容 mysql， 21:32:12 From window930030@gmail.com : SQL injection 有做嗎？ 21:32:27 From Wei Yao : SQL injection？SQL 注入？ 21:32:40 From Wei Yao : 我们不叫 sql 注入 21:32:55 From window930030@gmail.com : 恩？ 21:33:04 From Wei Yao : 我们会把 sql 变成算子，之后会去优化算子结构，下面会讲， 21:33:15 From window930030@gmail.com : 好的，謝謝。 21:34:55 From jeffery : 刚刚的意思：Visitor是选择节点 21:34:58 From jeffery : ？ 21:35:05 From Wei Yao : 不是 21:35:11 From Abner Zheng : 一种设计模式 21:35:13 From xietengjin : 遍历节点用的吧 21:35:14 From Wei Yao : visitor 是设计模式中的那个 visitor 模式 21:35:17 From Wei Yao : 对 21:35:19 From jacobz : 遍历树用的 21:35:23 From Fangfang Qi : 是遍历语法树的 21:35:27 From jeffery : 额，好的 21:35:28 From Wei Yao : 遍历 ast 树 21:37:03 From jeffery : 清楚 21:40:01 From jacobz : 是搞优化的那一堆？ 21:43:45 From lk : 递归遍历？ 21:44:05 From Wei Yao : 层级有限。 21:48:06 From Kathy : 其实这个时候是不是类似传统的通过运算符进栈出栈形成表达式 21:48:24 From Wei Yao : 对，表达式系统基本上都是这样 21:51:21 From Kathy : ScalarFunction能解决aggregation的函数的语句吗 21:55:24 From Chen Shuang : 能 21:55:55 From Chen Shuang : aggregation function 也是 scalar function. 21:57:23 From Kathy : 只要不涉及其他表的相关列的function是否都最后成为scalarFunction 21:57:33 From Kathy : 的表达式 21:58:40 From Chen Shuang : 只要是 function , 都会变成 scalarFunction 表达式 21:59:40 From Chen Shuang : select t1.a + t2.b from t1,t2; 其中 t1.a + t2.b 会build 成一个 scalarFunction 表达式 21:59:40 From Kathy : 多谢答复 22:00:28 From Chen Shuang : 不客气哈 22:06:26 From tianyi wang : select coalesce（）也会是scalarfunction? 22:06:53 From hezhiyong : 可以演示一下debug一条语句跑的代码吗 22:10:07 From jiangchen : 是的，能不能最好演示下。。每次next返回的是一部分子结果还是一部分最终的结果？ 22:11:33 From Kathy : 执行引擎的新特性可以说说吗？简单讲一下，就是parallel physical operator的实现等等 22:11:57 From Wei Yao : 执行引擎下周讲 22:12:05 From 慢摇哥哥 : 老师，Coprocessor是在哪一步分发的 22:12:06 From jeffery : 辛苦了，有一个基本的逻辑了 22:12:37 From Kathy : 好的 谢谢 22:12:42 From 达 黄 : 之前看了tidb源码解析的文章 配合着这个视频 印象更清楚了 22:13:32 From jeffery : 感觉姚老师像一位老教授在督导 22:14:02 From Wei Yao : ：） 22:15:40 From jeffery : 为什么这部分会单独出来？ 22:15:40 From nange : Distsql是什么好像没讲。 22:15:54 From tianyi wang : select coalesce（）会是scalarfunction还是单独的一部分呢? 22:18:53 From 熊浪 : 问下是每一个session都会解析一次sql么？如果一个sql在同一个session中多次执行是否有ast的共享？ 22:21:02 From hezhiyong : prepare 是要开启参数才可以的吧 22:21:36 From 熊浪 : 好的，和mysql是一样的。谢谢\nPPT: https://reading-go.slack.com/files/U8A45L223/FKA335THT/_reading-go__tidb_source_cdoe_overview.pdf\n观看视频   ","title":"第 46 期 TiDB 源码阅读之概览"},{"location":"http://bytemode.github.io/reading/45-2019-05-30-goim-reading/","text":" 观看视频   ","title":"第 45 期 goim 架构设计与源码分析"},{"location":"http://bytemode.github.io/reading/44-2019-05-29-go-map-reading/","text":" 观看视频   ","title":"第 44 期 Go map 源码阅读分析"},{"location":"http://bytemode.github.io/reading/43-2019-05-23-gomonkey-framework-design-and-practives/","text":" 观看视频   ","title":"第 43 期 gomonkey 框架设计与应用实践"},{"location":"http://bytemode.github.io/reading/42-2019-05-16-go-failpoint-design/","text":" 观看视频   ","title":"第 42 期 An Introduction to Failpoint Design"},{"location":"http://bytemode.github.io/reading/41-2019-05-12-golint-golangci-lint/","text":" 观看视频   ","title":"第 41 期 golint 及 golangci-lint 的介绍和使用"},{"location":"http://bytemode.github.io/reading/40-2019-04-27-atomic-value-in-go/","text":" 观看视频   ","title":"第 40 期 atomic.Value 的使用和源码分析"},{"location":"http://bytemode.github.io/reading/39-2019-04-18-init-function-in-go/","text":" 观看视频   ","title":"第 39 期 init function 使用分析"},{"location":"http://bytemode.github.io/reading/38-2019-04-13-k8s-scheduler-reading/","text":" 观看视频   ","title":"第 38 期 kubernetes scheduler 源码阅读"},{"location":"http://bytemode.github.io/reading/37-2019-04-01-talk-from-serverless-in-apache-pulsar/","text":" 参考资料  预习材料 pulsar-effectively-once  观看视频   ","title":"第 37 期 从 serverless 的一个设计说起"},{"location":"http://bytemode.github.io/reading/36-2019-03-28-reading-k8s-context/","text":" 实践  WithValue WithCancel WithTimeout  WithDeadline 基本上没有用到。\n参考资料  How to correctly use context.Context in Go 1.7 How to correctly use package context 视频笔记：如何正确使用 Context - Jack Lindamood  观看视频   ","title":"第 36 期 k8s context 实践源码阅读"},{"location":"http://bytemode.github.io/reading/35-2019-03-21-reading-context/","text":" 预习材料 第 35 期 Go 夜读之《context 包源码阅读》预习资料 #191\n观看视频   ","title":"第 35 期 context 源码阅读"},{"location":"http://bytemode.github.io/reading/34-2019-03-16-plan9-guide/","text":" 2019.3.16 晚上 21 点 ~ 23点\n直播过程中的文字讨论 （如有涉及到隐私，请告知） 21:08:32 From xiong hekuan : 几乎没有 21:08:47 From amatist Kurisu : 大佬开下麦... 21:09:02 From Laily Long : 能听到 21:09:02 From xiong hekuan : 可以 21:09:03 From 何翔宇 : 可以 21:09:06 From xiye : 能听到 21:09:09 From haoc7 : 听到了 21:09:12 From 星星 : 挺清楚的 21:11:01 From amatist Kurisu : ok 21:13:57 From panda : 👍 21:15:40 From albert’s iPhoneSE : 32位都差不多复杂 21:28:15 From 红红火火 : 不太好理解 21:28:24 From dongzerun : rax rbx ….. 一共六个，再多的才通过栈 21:32:09 From 红红火火 : 每个方法都有一个zhanma 21:32:22 From HLewis : 销毁就是sp等于bp吧 21:33:06 From albert’s iPhoneSE : 怎么修改栈大小？ 21:33:10 From 红红火火 : 每个方法都有一个栈指针吗 21:33:19 From Flora Wong : C++里inline函数就没有栈吧 21:33:52 From xiaolong ran : 失效后还给操作系统它怎么处理 ？ 21:34:35 From 红红火火 : 回收再利用吧 21:37:42 From 王耀峰 : 这是当时的值或者地址吧 21:37:49 From amatist Kurisu : 那cpu切换任务的话, 保存的上下文是指寄存器中的值么 21:38:08 From amatist Kurisu : ok 21:42:08 From 王耀峰 : 问个问题啊。系统条用，还会涉及到了内核态或者用户态切换吧，汇编有体现吗 21:42:42 From 王耀峰 : ok 21:42:45 From xiaolong ran : .bss 和 .rodata这两个和.text和.data是怎么交互的 21:43:30 From Laily Long : 就相当于系统调用的时候按要求把参数天刀对应寄存器，然后调用 syscall 进内核，内核就会自己拿参数然后执行对吧，返回的参数也写到固定寄存器？ 21:43:32 From dongzerun : 这哪有交互的说法 21:43:46 From z : syscall 不属于体系架构的指令，而是操作系统提供的？ 21:44:13 From dongzerun : 其它平台有的是不叫 syscall 21:46:59 From Laily Long : $ 表示数字？ 21:47:45 From Laily Long : plan9 是另一个操作系统的项目，不过凉了 21:54:25 From Flora Wong : zhuji 码 是哪两个字？ 21:54:30 From daniel : 不同的assembler 21:55:08 From atlas : 助记码 21:55:12 From 影子的 iPhone : 助记码 21:58:46 From 王耀峰 : 这种应该应该还有一种好处，所有栈信息都保存在协程的结构体里面，省去了好多上线文切换的开销了 22:01:58 From Laily Long : 是不是判断了之后 jmp 到不同的地方 22:05:01 From 卜邪 小 : SB代表什么？ 22:05:45 From Flora Wong : SB是某个寄存器？ 22:06:09 From daniel : SB: Static base pointer: global symbols. 22:06:13 From Odyssey : 所有的外部引用都需通过伪寄存器: PC（virtual Program Counter）/SB（Static Base register） 22:06:25 From Odyssey : 刚搜索的 ：） 22:09:17 From HLewis : 尾递归讲的好，只是有人介绍过，自己没跟过，学习了 22:13:00 From daniel : 能否分析一个函数调用时stack的结构？ 22:13:18 From 卜邪 小 : 不会被抢占？ 22:14:23 From 王耀峰 : 那也就是说gc 没办法正常回收了 22:14:54 From 王耀峰 : 我记得Go 里面好像有一个兜底策略 22:15:37 From pingzheng : 那写gorouting感觉好危险 22:15:46 From liu : 纯运算的是抢占不了 22:15:51 From 王耀峰 : 好好 22:15:53 From 王耀峰 : 还好 22:17:43 From 卜邪 小 : 在听 22:18:17 From z : SB的作用是 22:19:03 From 王耀峰 : 一个G的栈初始化只有2k 22:19:42 From xiye : goroutine的初始分配的内存是2k吧 22:19:59 From 红红火火 : 4k 22:20:19 From 王耀峰 : 这个应该和操作系统，虚拟内存有关吧 22:20:44 From 王耀峰 : 物理不可能，虚拟的也不会 22:23:22 From HLewis : 等一下能讲讲，所有的goroutine都在同一个操作系统进程中吗？ 22:23:30 From dingliu : 所以想到一个case，如果被调用的函数只有一个字符的变量还没超过2k，就不会触发morestack. 22:23:49 From 红红火火 : 去看gmp 22:30:23 From dingliu : ＋8是指8字节吗？ 22:33:45 From z : textflag.h是什么 22:35:55 From Laily Long : 怎么知道 slice 在汇编里是传了三个参数进去的 22:36:05 From Laily Long : 去哪里查，比如我要知道 map 的 22:37:13 From Laily Long : 哦哦。。懂了。。 22:40:02 From 王耀峰 : 后面的值是什么意思 22:40:26 From 王耀峰 : 哈哈，我擦 22:40:41 From 王耀峰 : 这还得算内存对齐了，哈哈 22:41:03 From Flora Wong : 黑科技 太牛 22:43:17 From 榴莲 : 🐂 22:43:41 From 红红火火 : 雨痕是不是很懂这些啊 22:46:01 From Flora Wong : 汇编有点意思 感谢大佬分享 22:46:29 From mai yang : 👍汇编还给老师了。 22:46:33 From xiye : defer一般用来做资源解锁比较好 22:46:37 From HLewis : 所有的goroutine都处在同一个操作系统进程中吗？ 22:46:42 From mai yang : defer 确实很尴尬的。 22:47:25 From 红红火火 : 线程队列里 22:47:51 From haoc7 : 上次有人线上defer没走到，前面崩了，找了半天是defer没走到。 22:48:11 From 王耀峰 : panic了 22:48:21 From z : go语言问题是追的github上issue么？ 22:48:33 From mai yang : pgraph? 22:48:38 From Xargin : pprof 22:48:40 From mai yang : pprof 22:49:18 From mai yang : 太感谢老师今天的分享了 22:49:21 From 卜邪 小 : 有 22:49:23 From 卜邪 小 : https://github.com/golang/go/blob/master/src/runtime/asm_amd64.s#L253 22:49:32 From mai yang : 在群里面 22:49:35 From 卜邪 小 : 老师能帮忙翻译这段汇编吗？ 22:49:40 From Feng Zhu : 谢谢大神分享 22:50:00 From hawken : 还有一个小小的问问，chrome 插件第三个是什么插件啊😂 22:50:13 From HLewis : 所有的goroutine都处在同一个操作系统进程中吗？ 22:50:22 From haoc7 : 哈哈哈，我刚刚也搜了 22:50:23 From 红红火火 : jstogo 22:50:27 From Laily Long : 请问下 Plan9 的汇编优势在哪里，为啥 go 的开发者会抛弃其他的自己造这个轮子 22:50:28 From Flora Wong : 哈哈 你的插件看起来都很棒 22:51:00 From mai yang : 这些插件都可以总结一波。 22:51:22 From Flora Wong : 回头分享一下插件名称哈 大佬 22:52:02 From 星星 : 我看到油猴了 22:52:15 From 王耀峰 : G应该是个宏封装吧 22:52:23 From HLewis : go协程和操作系统进程啥关系？ 22:52:46 From Flora Wong : 一个go程序执行的时候就是一个进程 肯定goroutine都在一个进程里啊 22:52:52 From Flora Wong : 你是想问线程吧？ 22:52:55 From 王耀峰 : 可以从网上看看经典的go的 GMP 22:52:57 From Laily Long : 这个你需要去看 gmp 模型 22:53:10 From HLewis : 好的我先搜一下 22:55:36 From William的 iPhone : 比较迷惑的是协程都在一个进程里面，那他怎么用满多核服务器的 22:56:18 From 王耀峰 : 中间层？ 22:56:30 From HLewis : 对 22:56:48 From HLewis : 系统级别只有进程 22:57:03 From HLewis : 线程是提供的库比如pthreads 22:57:56 From HLewis : 如果协程都在一个进程中，那么就意味着所有协程共享同一个虚拟内存空间， 22:58:37 From HLewis : 那么操作系统提供的进程间ipc跟Go就没有毛关系了？ 22:59:55 From daniel : 比较迷惑的是协程都在一个进程里面，那他怎么用满多核服务器的 22:59:59 From daniel : 多线程呀 23:01:03 From 王耀峰 : 不一定是一个进程，其实G的存在就减少了上下文切换，底层还是多喝都绑定到P上相当于多核了吧 23:01:06 From William的 iPhone : 协程之间走进程间通信吗？ 23:01:54 From William的 iPhone : 多个线程之间的goroutine 怎么通信？ 23:02:08 From 王耀峰 : channel 23:03:02 From William的 iPhone : 说错了是多个核上的多个进程上面的goroutine 之间的通信 23:03:34 From daniel : 啥，一个Go程序跑起来是单进程的呀 23:03:48 From 王耀峰 : Go其实弱化了这些进程线程概念，你遵循mpg这种用就行了 23:03:51 From wangriyu : 不同进程得走系统ipc了吧 23:04:07 From William的 iPhone : 单进程能用满多个核心么 23:04:12 From William的 iPhone : 迷糊了 23:04:14 From Xargin : debug.xxxstack() 23:04:41 From wangriyu : 进程是资源分配的基本单元，线程才是执行单元 23:04:54 From 王耀峰 : 对 23:05:07 From wangriyu : 你多线程跑就能跑满cpu了 23:05:08 From daniel : 一个进程可以搞出来n个线程，这n个线程会执行m个goroutine 23:05:24 From 王耀峰 : 在linux 下层其实进程线程好像不太严格。弱进程 23:06:39 From daniel : 同一个进程下的线程共享很多资源 23:06:48 From William的 iPhone : 这m个在一个核心里面？我理解的一个进程只能用满一个核心吧 23:07:04 From tanrongxian : 峰哥牛鼻 23:07:07 From mai yang : 非常感谢 23:07:07 From luckybear : 多谢大佬 23:07:07 From pingzheng : 感谢大佬 23:07:08 From HLewis : 学习了，谢谢分享 23:07:09 From Laily Long : 辛苦大佬 23:07:14 From Flora Wong : 感谢 @Xargin 23:07:16 From hawken : 非常感谢 23:07:18 From Odyssey : 谢谢分享 23:07:18 From wangriyu : 感谢 23:07:18 From doujiapeng : 感谢感谢 23:07:18 From qclaogui : 辛苦大佬 23:07:21 From 星星 : 感谢 23:07:22 From tanrongxian : 感谢分享 23:07:24 From 饶全成 : 感谢 23:07:24 From Flora Wong : 辛苦大佬 23:07:25 From Feng Zhu : 大佬 23:07:25 From 卜邪 小 : 谢谢 23:07:32 From daniel : 感谢，睡觉了 23:07:33 From amatist Kurisu : 感谢分享 23:07:34 From doujiapeng : 多谢 23:07:36 From haoc7 : 谢谢大佬 23:07:38 From qclaogui : good night 23:07:41 From Odyssey : 谢谢大佬 23:07:46 From 鹏飞 : 6 23:07:49 From mai yang : 晚点分享出来给大家 23:07:50 From HLewis : gnight  观看视频   ","title":"第 34 期 Go 夜读之 plan9 汇编入门，带你打通应用和底层 by Xargin"},{"location":"http://bytemode.github.io/reading/1-2019-03-14-daily-reading/","text":" 阅读清单    标题 阅读者     漫话：如何给女朋友解释为什么有些网站域名不以 www 开头 mai   LeetCode 的刷题利器（伪装到老板都无法 diss 你没有工作） mai   深入 GO 语言文本类型 ch   k8s cpu 资源限制 k8s 内存资源限制 Jason   Golang 之轻松化解 defer 的温柔陷阱 关于 go 语言中的延迟执行函数 Littlesqx    “漫话”的阅读笔记  域名的一个重要功能——为数字化的互联网资源提供易于记忆的名称。 域名具有唯一性。 www，其实是 World Wide Web 的缩写，中文翻译为万维网 互联网并不等同万维网（WWW），万维网只是一个基于超文本相互链接而成的全球性系统，且是互联网所能提供的服务其中之一。 为了区分互联网中的各种应用，就有了不同的子域名，比如互联网就以 www 作为子域名，文件传输以 ftp 作为子域名，电子邮件以 mail 作为子域名。 正是因为万维网是互联网中最重要的一部分，很多域名的最主要用途也是搭建 web 网站，所以，会有很多公司直接忽略 www。 通用顶级域（英语：Generic top-level domain，缩写为 gTLD），是互联网名称与数字地址分配机构（IANA）管理的顶级域（TLD）之一。该机构专门负责互联网的域名系统。 域名支持中文，并且域名中也已经支持颜文字了。“👀.我爱你”  “Go文本类型”的阅读笔记  为什么字符串直接取下标，s[0] 类型是 byte，range 时 类型为 rune？ k,v := range string，k 是 UTF-8 编码字节的下标，v 是 Unicode。For statements with range clause 扩展 fmt 格式化  k8s 资源限制  pod 调度是按 container 中 request 资源总和调度的； limit 帮助 kubelet 约束本节点上容器资源使用最大份额； 针对 内存 这种不可压缩资源，超额将导致 container 中程序 OOM 退出；而 CPU 只是影响了程序的等待时长； 内存资源：cgroup 中 memory.limit_in_bytes (最大内存 limit 份额)、memory.soft_limit_in_bytes (request 内存份额) CPU 资源，分两部分：  request cpu 份额: cgroup 中 cpu.shares，其中记录的数值是 CPU 分片数，一个 CPU 分为 1024 片（k8s 分成 1000 片），request.memory: 500m 表示申请 500\u0026frasl;1000 个 cpu; 它保证程序能接收到申请的份数 CPU 片，但是如果程序没完全使用，其他程序是可以占用的； limit cpu 份额：cpu.cfs_period_us 表示一个 CPU 执行时间周期的时间，通常为 100ms（带宽控制系统定义了一个通常是 1\u0026frasl;10 秒的周期）;cpu.cfs_quota_us 表示一个周期内分配的 CPU 时间; cpu.cfs_period_us/cpu.cfs_quota_us 合起来表示 limit 的 CPU 份额；  查看 cgroup 命令：  1. 找到容器中程序在宿主机上进程 ID $ cat /proc/${PID}/cgroup ... 8:cpuacct,cpu:/kubepods/burstable/podxxx/dockerid 7:memory:/kubepods/burstable/podxxx/dockerid ... 2. ls /sys/fs/cgroup/cpuacct,cpu/kubepods/burstable/podxxx/dockerid/ 3. ls /sys/fs/cgroup/memory/kubepods/burstable/podxxx/dockerid  “defer” 笔记  每次 defer 语句执行的时候，会把函数“压栈”，函数参数会被拷贝下来；当在当前函数执行完毕后（包括通过 return 正常结束或者panic 导致的异常结束），defer 函数按照定义的逆序执行；如果 defer 执行的函数为 nil, 那么会在最终调用函数的产生 panic。 Golang 内置的带返回值的函数无法进行延迟调用（调用的结果不可以抛弃，copy 和 recover 例外），可通过放入到匿名函数中再 defer。 defer 常用场景：控制资源（文件、数据库、锁等）的申请和释放，使代码简洁；配合 recover 实现异常恢复。 defer 副作用（坑）：延迟执行的机制损耗性能；延迟意味着资源占用，需要时刻警惕尽可能早地释放。  观看视频   ","title":"第 1 期每日阅读特训营"},{"location":"http://bytemode.github.io/reading/33-2019-03-07-defer-in-go/","text":" 2019.3.7 晚上\n观看视频   ","title":"第 33 期 Go 夜读之 Go defer 和逃逸分析"},{"location":"http://bytemode.github.io/reading/32-2019-03-02-etcd-raft/","text":" etcd raft 阅读\netcd 版本：3.3.10\n2019.3.2 晚上\n总结 etcd里的raft模块只实现了raft共识算法，而像消息的网络传输，数据存储都由上层应用来完成。\n下面是各个文件（夹）的功能简介：\n raftpb  用Protocol Buffer定义了一些需要序列化的数据结构，比如Entry和Message。\n log_unstable.go  unstable数据结构表示用于还没有被用户层持久化的数据，它维护了两部分内容snapshot和entries。\n storage.go  这个文件定义了一个Storage接口，应用层需要实现这个接口，以提供存储和查询日志的能力。\n log.go  维护本地日志信息。其中的committed和applied分别表示已提交和已经应用到状态机的日志索引。\n progress.go  Leader节点通过Progress这个数据结构来追踪一个follower的状态，并根据Progress里的信息来决定每次同步的日志项。\n raft.go  Raft协议的具体实现就在这个文件里。其中最重要的就是Step函数，它用来处理不同的消息。所以以后当我们想知道raft对某种消息的处理逻辑时，到这里找就对了。\n node.go  node的主要作用是应用层和共识模块（raft）的衔接。将应用层的消息传递给底层共识模块，并将底层共识模块共识后的结果反馈给应用层。\n参考资料  深入浅出 Raft - 基本概念 深入浅出 Raft - Membership Change 深入浅出 Raft - Leader 选举 深入浅出 Raft - Optimization Raft在etcd中的实现 etcd contrib Etcd超全解：原理阐释及部署设置的最佳实践  观看视频   ","title":"第 32 期 Go 夜读之 etcd raft 源码阅读"},{"location":"http://bytemode.github.io/reading/31-2019-02-23-flag/","text":" Go 标准包阅读\nGo 版本：go 1.11.5\n总结  *v.URL = *u flag 下有 package flag_test？？ init 中定义相同的 stringvar ； 当一个文件中出现多个 init 函数时，他们都会被加载，并且以 init 出现在文件中的前后顺序执行。   type Value interface { String() string Set(string) error } type Getter interface { Value Get() interface{} } type boolFlag interface { Value IsBoolFlag() bool }  strconv.ParseBool 的返回值可以被利用  v, err := strconv.ParseBool(s) *b = boolValue(v) return err 参考资料  Go 语言中值 receiver 和指针 receiver 的对比（收集的一些资料）  观看视频   ","title":"第 31 期 Go 夜读之 flag 包源码阅读"},{"location":"http://bytemode.github.io/reading/30-2019-02-16-go-mod-part-4/","text":" Go 标准包阅读\nGo 版本：go 1.11.5\nnet/http  `` 换行  本期没有视频回放。\n观看视频   ","title":"第 30 期 Go 夜读之 go mod 源码阅读 part 4"},{"location":"http://bytemode.github.io/reading/29-2019-01-23-opentracing-jaeger-in-go/","text":" Go opentracing jaeger 集成及源码分析 一、分布式追踪论文 论文地址：http://bigbully.github.io/Dapper-translation/\n为什么要用分布式追踪  当代的互联网的服务，通常都是用复杂的、大规模分布式集群来实现的。 互联网应用构建在不同的软件模块集上，这些软件模块，有可能是由不同的团队开发、 可能使用不同的编程语言来实现、有可能布在了几千台服务器，横跨多个不同的数据中心。 因此，就需要一些可以帮助理解系统行为、用于分析性能问题的工具。\n 分布式系统调用过程 使用分布式追踪要留意哪些问题  低损耗\n 跟踪系统对在线服务的影响应该做到足够小。\n 应用透明\n 对于应用的程序员来说，是不需要知道有跟踪系统这回事的。\n  二、Opentracing简介 Opentracing的作用  OpenTracing通过提供平台无关、厂商无关的API，使得开发人员能够方便的添加（或更换）追踪系统的实现。  可以很自由的在不同的分布式追 踪系统中切换\n 不负责具体实现\n  Opentracing主要组成  一个Trace \u0026gt; 一个trace代表了一个事务或者流程在（分布式）系统中的执行过程\n Span \u0026gt; 记录Trace在执行过程中的信息\n 无限极分类 \u0026gt; 服务与服务之间使用无限极分类的方式，通过HTTP头部或者请求地址传输到最低层，从而把整个调用链串起来。\n  Jaeger-client的实现 Jaeger-client源码 提取  为什么要提取 \u0026gt; 主要作用是为了找到父亲\n 从哪里提取 \u0026gt; 进程内，不同进程之间各自约定 \u0026gt; 粟子：github.com/opentracing-contrib/go-stdlib/nethttp/server.go P86\n 提取什么 \u0026gt; traceid:spanid:parentid:是否采集 \u0026gt; uber-trace-id=157b74261b51d917:157b74261b51d917:0:1 \u0026gt; github.com/jaegertracing/jaeger-client-go/propagation.go P124\n  注入  为什么要注入 \u0026gt; 主要为了让孩子能找到爸爸\n 注入到哪里 \u0026gt; 和提取相对 \u0026gt; github.com/jaegertracing/jaeger-client-go/propagation_test.go\n 注入了什么 \u0026gt; github.com/jaegertracing/jaeger-client-go/propagation.go P103\n  异步report  Span.finish \u0026gt; github.com/jaegertracing/jaeger-client-go/span.go P177\n 把Span放入队列 \u0026gt; github.com/jaegertracing/jaeger-client-go/reporter.go P219\n 从队列取出，生成thrift，放入spanBuffer \u0026gt; github.com/jaegertracing/jaeger-client-go/reporter.go P253\n Flush到远程 \u0026gt; github.com/jaegertracing/jaeger-client-go/transport_udp.go P113\n  低消耗  消耗在哪里 \u0026gt; Jaeger-client作用于应用层，提取、注入、生成span、序列化成Thrift、发送到远程等，一系列操作这些都会带来性能上的损耗。\n 如何处理 \u0026gt; 选择合适采集策略：\n Constant Probabilistic Rate Limiting Remote   应用透明  如何做到让业务开发人员无感知  Golang： 约定第一个参数为ctx，把parentSpan放入ctx github.com/opentracing/opentracing-go/gocontext.go PHP： 使用全局变量   三、Jaeger服务端源码阅读 服务端组件职责  各组件按照微服务架构风格设计，职责单一\n  Jaeger-agent负责上报数据的整理\n Jaeger-collector负责数据保存\n Jaeger-query负责数据查询\n Jaeger-agent和Jaeger-collector使用基于TCP协议实现的RPC进行通讯\n  Jaeger-agent 源码阅读  监听3个UDP端口\n\u0026gt; github.com/jaegertracing/jaeger/cmd/agent/app/flags.go P35 \u0026gt; github.com/jaegertracing/jaeger/cmd/agent/app/servers/thriftudp/transport.go P73\n 接收Jaeger-client的数据，放入队列dataChan \u0026gt; github.com/jaegertracing/jaeger/cmd/agent/app/servers/tbuffered_server.go #80  从队列dataChan获取数据，进行校验 \u0026gt; github.com/jaegertracing/jaeger/cmd/agent/app/processors/thrift_processor.go P108\n 提交数据 \u0026gt; github.com/jaegertracing/jaeger/thrift-gen/jaeger/tchan-jaeger.go #39\n  Jaeger-collector 源码阅读  协程池 \u0026gt; github.com/jaegertracing/jaeger/pkg/queue/bounded_queue.go\n 接收jaeger-agent数据 \u0026gt; github.com/jaegertracing/jaeger/cmd/collector/app/span_handler.go P69\n 放入队列 \u0026gt; github.com/jaegertracing/jaeger/cmd/collector/app/span_processor.go P112\n 从队列拿出来，写入数据库\n\u0026gt; github.com/jaegertracing/jaeger/cmd/collector/app/span_processor.go p54\n\u0026gt; github.com/jaegertracing/jaeger/plugin/storage/cassandra/spanstore/writer.go P136\n  四、Jaeger使用经验 监听指标  Jaeger-client 监听 reporter_spans\n Jaeger-agent 监听 thrift.udp.server.packets.dropped\n Jaeger-collector 监听 spans.dropped\n  http://localhost:16686/metrics\n测试环境debug  测试环境记录执行mysql语句，redis命令，RPC参数、结果 可以很方便定位问题\n 性能调优  观察Jaeger-ui，对线上接口，mysql执行时间进行监控调优\n 观看视频   ","title":"第 29 期 Go opentracing jaeger 集成及源码分析"},{"location":"http://bytemode.github.io/reading/28-2019-01-17-go-mod-part-3/","text":" Go 标准包阅读\nGo 版本：go 1.11.5\n学到的内容  json:\u0026quot;,omitempty\u0026quot;   方法一：\nif path[len(path)-1] == \u0026#39;/\u0026#39; { return fmt.Errorf(\u0026#34;trailing slash\u0026#34;) } 方法二：\nstrings.HasSuffix(path, \u0026#34;/\u0026#34;) benchmark\n   方法一：\nstrings.TrimSuffix(pathMajor, \u0026#34;-unstable\u0026#34;) 方法二：\ni := len(path) if strings.HasSuffix(path, \u0026#34;-unstable\u0026#34;) { i -= len(\u0026#34;-unstable\u0026#34;) } benchmark\n   if i := strings.Index(arg, \u0026#34;@\u0026#34;); i \u0026gt;= 0 { path, vers = arg[:i], arg[i+1:] } 也可以用 split(arg, \u0026quot;@\u0026quot;) 来实现。\n观看视频   ","title":"第 28 期 Go 夜读之 go mod 源码阅读 part 3"},{"location":"http://bytemode.github.io/reading/27-2019-01-10-go-mod-part-2/","text":" Go 标准包阅读\nGo 版本：go 1.11.5\n学到的内容 1. mf := new(modfile.File) 2. lineno++ 感觉是无用的代码？ dep.go 中 ParseGopkgLock 方法第48行有用到 lineno ，会打印出 strconv.Unquote 解析错误的文件名和行号\nif len(val) \u0026gt;= 2 \u0026amp;\u0026amp; val[0] == \u0026#39;\u0026#34;\u0026#39; \u0026amp;\u0026amp; val[len(val)-1] == \u0026#39;\u0026#34;\u0026#39; { q, err := strconv.Unquote(val) // Go unquoting, but close enough for now  if err != nil { return nil, fmt.Errorf(\u0026#34;%s:%d: invalid quoted string: %v\u0026#34;, file, lineno, err) } val = q } 其他几个文件可能是为了保持一致，或者为了将来输出错误信息特意保留的。其他文件里面的 lineno 没有地方引用，大家在阅读代码时会产生困惑，建议用空白符_来替代。\n3. 判断外部网络是否可用 if runtime.GOOS == \u0026#34;nacl\u0026#34; || runtime.GOOS == \u0026#34;js\u0026#34; { t.Skipf(\u0026#34;skipping test: no external network on %s\u0026#34;, runtime.GOOS) } runtime.GOOS返回程序所在的操作系统名\nsrc\\runtime\\extern.go // GOOS is the running program\u0026#39;s operating system target: // one of darwin, freebsd, linux, and so on. const GOOS string = sys.GOOS Native Client(NACL) 是一种允许在浏览器中运行 native compiled code 的技术，允许开发者运用自己熟悉的语言来开发web应用，而不只是JavaScript，目前 NativeClient 技术只能应用于google自己的chrome中。 js 是指 Webassembly 技术，是在新版本1.11中才支持的,最新版本的浏览器可以支持。 NACL 和 JS 都不是真正的操作系统，不提供外部网络功能。\n4.旧版模块管理配置转换为modfile 读取当前目录下旧版模块管理配置文件，从 Converters 中根据配置文件名去获取转换方法。\nsrc\\cmd\\go\\internal\\modconv\\convert.go // ConvertLegacyConfig converts legacy config to modfile. // The file argument is slash-delimited. func ConvertLegacyConfig(f *modfile.File, file string, data []byte) error { i := strings.LastIndex(file, \u0026#34;/\u0026#34;) j := -2 if i \u0026gt;= 0 { j = strings.LastIndex(file[:i], \u0026#34;/\u0026#34;) } convert := Converters[file[i+1:]] if convert == nil \u0026amp;\u0026amp; j != -2 { convert = Converters[file[j+1:]] } if convert == nil { return fmt.Errorf(\u0026#34;unknown legacy config file %s\u0026#34;, file) } mf, err := convert(file, data) if err != nil { return fmt.Errorf(\u0026#34;parsing %s: %v\u0026#34;, file, err) } ... } src\\cmd\\go\\internal\\modconv\\modconv.go var Converters = map[string]func(string, []byte) (*modfile.File, error){ \u0026#34;GLOCKFILE\u0026#34;: ParseGLOCKFILE, \u0026#34;Godeps/Godeps.json\u0026#34;: ParseGodepsJSON, \u0026#34;Gopkg.lock\u0026#34;: ParseGopkgLock, \u0026#34;dependencies.tsv\u0026#34;: ParseDependenciesTSV, \u0026#34;glide.lock\u0026#34;: ParseGlideLock, \u0026#34;vendor.conf\u0026#34;: ParseVendorConf, \u0026#34;vendor.yml\u0026#34;: ParseVendorYML, \u0026#34;vendor/manifest\u0026#34;: ParseVendorManifest, \u0026#34;vendor/vendor.json\u0026#34;: ParseVendorJSON, } 目前go语言是使用map对象来存储旧配置文件和方法的映射关系这种设计思路的。@mai提出还有一种设计思路是抽象一个接口，各种配置管理来实现该接口。\n观看视频   参考 1.Google Native Client\n2.NaCl and networking\n3.Go 1.11 正式发布 支持模块和WebAssembly\n4.WebAssembly 现状与实战\n","title":"第 27 期 Go 夜读之 go mod 源码阅读 part 2"},{"location":"http://bytemode.github.io/reading/26-2019-01-03-blog-with-github-netlify/","text":" Github Netlify 观看视频   ","title":"第 26 期 Go 夜读之手把手教你基于 Github+Netlify 构建自动化持续集成的技术团队博客"},{"location":"http://bytemode.github.io/reading/25-2018-12-27-tsdb/","text":" TSDB 引擎介绍，对比及存储细节  OpenTSDB InfluxDB Druid  观看视频   ","title":"第 25 期 TSDB 引擎介绍，对比及存储细节"},{"location":"http://bytemode.github.io/reading/24-2018-12-23-go-mod-part-1/","text":" Go 标准包阅读\nGo 版本：go 1.11.5\n观看视频   阅读重点  os.Stat filepath.SplitList os.Getwd() switch sync.Once os.IsNotExist(errMod) MustQuote AutoQuote modcmd.runGraph  format := func(m module.Version) string { if m.Version == \u0026#34;\u0026#34; { return m.Path } return m.Path + \u0026#34;@\u0026#34; + m.Version }  sort.Slice  什么是 go mod module 是相关 Go 依赖包的集合。module 是源代码交换和版本控制的单元。go 工具链会直接支持使用 go module，其功能包含记录和解析对其他第三方包的依赖项。模块将会替换旧的基于 $GOPATH 的模式\n目前 Go1.11 是初步支持，后续建议持续观望一下。详见 godoc\n开关 由于当前还在试验阶段，需要设置环境变量 GO111MODULE=on，才能够使用 go mod。支持一下选项：\n off：禁用 go module，按原有 $GOPATH、vendor 的寻址逻辑 on：启用 go module auto：若当前不在 $GOPATH 下，且当前目录的根目录下含有 go.mod 文件。则启用 go module  go mod 一下 $ go mod Go mod provides access to operations on modules. Note that support for modules is built into all the go commands, not just 'go mod'. For example, day-to-day adding, removing, upgrading, and downgrading of dependencies should be done using 'go get'. See 'go help modules' for an overview of module functionality. Usage: go mod \u0026lt;command\u0026gt; [arguments] The commands are: download download modules to local cache edit edit go.mod from tools or scripts graph print module requirement graph init initialize new module in current directory tidy add missing and remove unused modules vendor make vendored copy of dependencies verify verify dependencies have expected content why explain why packages or modules are needed Use \u0026quot;go help mod \u0026lt;command\u0026gt;\u0026quot; for more information about a command.   download：将 modules 下载到本地缓存 edit：对 go.mod 进行编辑。具体可参见 go help mod edit init：初始化 go module tidy：检索代码，新增缺少的依赖，删除不需要的依赖 vendor：拷贝依赖，生成 vendor 目录 verify：验证依赖是否正确 why：解释为什么需要依赖和 modules  怎么找源码 在这里我们用最粗暴也是最简洁的办法，直接搜一下。在这里，我们找到了如下苗头：\n cmd/go/alldocs.go：go cmd 的文档。是通过 mkalldocs.sh 在其他文件中收集注解生成的 godoc cmd/go/internal/modcmd/mod.go：今天的男主角，go module 的代码就存储在 modcmd 目录下。而其实我们搜索到的 mod.go 就是 go mod 这个命令的启动文件  看一看源码 modcmd ├── download.go ├── edit.go ├── graph.go ├── init.go ├── mod.go ├── tidy.go ├── vendor.go ├── verify.go └── why.go  通过 modcmd 的文件结构，可以惊喜地发现与 go mod \u0026lt;command\u0026gt; 的指令集其实是一致的。那么阅读的方向就很清晰了，我们可以按逻辑顺序看下去\ninit.go package modcmd import ( \u0026quot;cmd/go/internal/base\u0026quot; \u0026quot;cmd/go/internal/modload\u0026quot; \u0026quot;os\u0026quot; ) var cmdInit = \u0026amp;base.Command{ UsageLine: \u0026quot;go mod init [module]\u0026quot;, Short: \u0026quot;initialize new module in current directory\u0026quot;, Long: `Init initializes and writes a new go.mod to the current directory...`, Run: runInit, } func runInit(cmd *base.Command, args []string) { modload.CmdModInit = true if len(args) \u0026gt; 1 { base.Fatalf(\u0026quot;go mod init: too many arguments\u0026quot;) } if len(args) == 1 { modload.CmdModModule = args[0] } if _, err := os.Stat(\u0026quot;go.mod\u0026quot;); err == nil { base.Fatalf(\u0026quot;go mod init: go.mod already exists\u0026quot;) } modload.InitMod() // does all the hard work }  cmdInit cmdInit 实际为定义 cmd 命令的基础结构体，其包含成员变量如下：\n UsageLine：用法 Short：简短描述 Long：详细描述 Run：运行命令  其对应的触发场景主要是 help 和执行命令时，如下：\n➜ ~ go help mod init usage: go mod init [module] Init initializes and writes a new go.mod to the current directory, in effect creating a new module rooted at the current directory. The file go.mod must not already exist. If possible, init will guess the module path from import comments (see 'go help importpath') or from version control configuration. To override this guess, supply the module path as an argument.  runInit  声明正在执行 go mod init 命令集 判断参数是否不合法 参数合法下，该入参赋值给 go mod init 的 module 参数（将 args[0] 赋予 CmdModModule） 判断是否存在 go.mod 文件（也就是判断是否已经初始化过） 在 modload.InitMod() 中正式进行初始化的所有工作项  modload.InitMod() 源码中用 “does all the hard work” 来评价这个方法，它是 go mod init 的核心处理逻辑。接下来一起来看看 完整代码，我们将分为两个部分去阅读，如下：\n一、MustInit\nfunc MustInit() { if Init(); ModRoot == \u0026quot;\u0026quot; { die() } if c := cache.Default(); c == nil { base.Fatalf(\u0026quot;go: cannot use modules with build cache disabled\u0026quot;) } }  在该方法中，我们先进行必要的初始化，再读取构建缓存（不是本文重点），接下来详细阅读一下 Init 方法，如下：\nfunc Init() { ... env := os.Getenv(\u0026quot;GO111MODULE\u0026quot;) switch env { default: base.Fatalf(\u0026quot;go: unknown environment setting GO111MODULE=%s\u0026quot;, env) case \u0026quot;\u0026quot;, \u0026quot;auto\u0026quot;: // leave MustUseModules alone case \u0026quot;on\u0026quot;: MustUseModules = true case \u0026quot;off\u0026quot;: if !MustUseModules { return } } if os.Getenv(\u0026quot;GIT_TERMINAL_PROMPT\u0026quot;) == \u0026quot;\u0026quot; { os.Setenv(\u0026quot;GIT_TERMINAL_PROMPT\u0026quot;, \u0026quot;0\u0026quot;) } if os.Getenv(\u0026quot;GIT_SSH\u0026quot;) == \u0026quot;\u0026quot; \u0026amp;\u0026amp; os.Getenv(\u0026quot;GIT_SSH_COMMAND\u0026quot;) == \u0026quot;\u0026quot; { os.Setenv(\u0026quot;GIT_SSH_COMMAND\u0026quot;, \u0026quot;ssh -o ControlMaster=no\u0026quot;) } var err error cwd, err = os.Getwd() if err != nil { base.Fatalf(\u0026quot;go: %v\u0026quot;, err) } inGOPATH = false for _, gopath := range filepath.SplitList(cfg.BuildContext.GOPATH) { if gopath == \u0026quot;\u0026quot; { continue } if search.InDir(cwd, filepath.Join(gopath, \u0026quot;src\u0026quot;)) != \u0026quot;\u0026quot; { inGOPATH = true break } } if inGOPATH \u0026amp;\u0026amp; !MustUseModules { if root, _ := FindModuleRoot(cwd, \u0026quot;\u0026quot;, false); root != \u0026quot;\u0026quot; { cfg.GoModInGOPATH = filepath.Join(root, \u0026quot;go.mod\u0026quot;) } return } if CmdModInit { ModRoot = cwd } else { ... if search.InDir(ModRoot, os.TempDir()) == \u0026quot;.\u0026quot; { ModRoot = \u0026quot;\u0026quot; fmt.Fprintf(os.Stderr, \u0026quot;go: warning: ignoring go.mod in system temp root %v\\n\u0026quot;, os.TempDir()) return } } ... search.SetModRoot(ModRoot) }   判断环境变量 GO111MODULE 选项，主要是设置是否支持 go.mod 和处理一些异常 判断环境变量 GIT_TERMINAL_PROMPT 选项，主要是涉及 Git 的密码弹窗输出提示的处理 判断环境变量 GIT_SSH 选项，主要是判断 Git SSH 连接池，默认为禁用 判断当前路径是否在 $GOPATH 下（可以注意 filepath.SplitList 相关联的代码。主要是读取了 $GOPATH 后利用特定标志位 : 进行了分隔，解决多 $GOPATH 的问题） 判断当前是否在 $GOPATH 下且没有打开 GO111MODULE 选项。若是则检索当前根目录下是否包含 go.mod 文件，存在则代表当前 $GOPATH 下存在 go.mod 文件，这里相对应的是 auto 选项时的逻辑 若当前 CmdModInit 为启用，则在当前目录下创建 go.mod 文件，否则将尽量尝试去临时目录寻找标志文件  当 modRoot 为空时，则触发异常处理，常见的一些错误提示如下：\nfunc die() { if os.Getenv(\u0026quot;GO111MODULE\u0026quot;) == \u0026quot;off\u0026quot; { base.Fatalf(\u0026quot;go: modules disabled by GO111MODULE=off; see 'go help modules'\u0026quot;) } if inGOPATH \u0026amp;\u0026amp; !MustUseModules { base.Fatalf(\u0026quot;go: modules disabled inside GOPATH/src by GO111MODULE=auto; see 'go help modules'\u0026quot;) } base.Fatalf(\u0026quot;go: cannot find main module; see 'go help modules'\u0026quot;) }  二、具体实现逻辑\nfunc InitMod() { ... if modFile != nil { return } list := filepath.SplitList(cfg.BuildContext.GOPATH) if len(list) == 0 || list[0] == \u0026quot;\u0026quot; { base.Fatalf(\u0026quot;missing $GOPATH\u0026quot;) } gopath = list[0] if _, err := os.Stat(filepath.Join(gopath, \u0026quot;go.mod\u0026quot;)); err == nil { base.Fatalf(\u0026quot;$GOPATH/go.mod exists but should not\u0026quot;) } oldSrcMod := filepath.Join(list[0], \u0026quot;src/mod\u0026quot;) pkgMod := filepath.Join(list[0], \u0026quot;pkg/mod\u0026quot;) infoOld, errOld := os.Stat(oldSrcMod) _, errMod := os.Stat(pkgMod) if errOld == nil \u0026amp;\u0026amp; infoOld.IsDir() \u0026amp;\u0026amp; errMod != nil \u0026amp;\u0026amp; os.IsNotExist(errMod) { os.Rename(oldSrcMod, pkgMod) } modfetch.PkgMod = pkgMod modfetch.GoSumFile = filepath.Join(ModRoot, \u0026quot;go.sum\u0026quot;) codehost.WorkRoot = filepath.Join(pkgMod, \u0026quot;cache/vcs\u0026quot;) if CmdModInit { // Running go mod init: do legacy module conversion legacyModInit() modFileToBuildList() WriteGoMod() return } gomod := filepath.Join(ModRoot, \u0026quot;go.mod\u0026quot;) data, err := ioutil.ReadFile(gomod) if err != nil { if os.IsNotExist(err) { legacyModInit() modFileToBuildList() WriteGoMod() return } base.Fatalf(\u0026quot;go: %v\u0026quot;, err) } f, err := modfile.Parse(gomod, data, fixVersion) if err != nil { // Errors returned by modfile.Parse begin with file:line. base.Fatalf(\u0026quot;go: errors parsing go.mod:\\n%s\\n\u0026quot;, err) } modFile = f if len(f.Syntax.Stmt) == 0 || f.Module == nil { // Empty mod file. Must add module path. path, err := FindModulePath(ModRoot) if err != nil { base.Fatalf(\u0026quot;go: %v\u0026quot;, err) } f.AddModuleStmt(path) } if len(f.Syntax.Stmt) == 1 \u0026amp;\u0026amp; f.Module != nil { // Entire file is just a module statement. // Populate require if possible. legacyModInit() } excluded = make(map[module.Version]bool) for _, x := range f.Exclude { excluded[x.Mod] = true } modFileToBuildList() WriteGoMod() }   判断是否已存在 go.mod 的文件句柄（代指已经处理过相应的逻辑） 检查 $GOPATH 是否设置，并判断 go.mod 文件是否已存在（代指是否已经初始化过） 若 oldSrcMod（src/mod）存在，则 pkgMod（pkg/mod) 不存在，则进行重命名。这里考虑为兼容性操作 若为初次初始化，则执行以下步骤  第一步先做兼容处理，也就是执行 legacyModInit() 对前身（vgo）的一些东西进行兼容处理转换为 go module 现在的模式 第二步执行 modFileToBuildList() 方法 从 modFile 中初始化 mod 构建列表 最后通过 WriteGoMod 进行逻辑处理后（例：处理最小依赖版本）将当前构建列表反写回 go.mod 文件  若并非初次初始化，将会读取 go.mod 文件，根据语法解析 go.mod 的文件内容。接下来会进行一些基准操作  若 go.mod 文件是否为空，则先通过 FindModulePath 检索现有的路径。另外在这里也做了 godeps、govendor 的兼容处理。寻找到 module path 后通过 AddModuleStmt() 添加 module path 到文件中 若只存在 module path，则通过 legacyModInit() 进行兼容处理 最后与上小点一致，均为构建回写等动作   总结 在 go module 中，更多的是本身对包管理工具的思考和实现。如果你仔细阅读过，可以想想如下方面：\n 为什么要这么做 为什么要在这个地方做 有没有更好的方法  依赖包管理工具，是 Go 一个比较要命的痛点。那为什么 go module 又能 \u0026ldquo;解决\u0026rdquo; 呢？请想想\u0026hellip;\n基于篇幅我没有把所有内容都写出来，但是写法、思维是类似的。有兴趣的同学可以认真看看视频，举一反三\n问题 Go 1.11 在 go mod edit -module a/new/mod/name 命令中的一个 bug go mod edit 命令的 -module flag 是用于修改当前 module 的 path。也就是 go.mod 文件中，module 那一行。 在这个命令的源码 src/cmd/go/internal/modcmd/edit.go 文件 177 行开始：\nif *editModule != \u0026#34;\u0026#34; { modFile.AddModuleStmt(modload.CmdModModule) } AddModuleStmt 这个函数的参数应该是 *editModule，而不是 modload.CmdModule。 modload.CmdModule 只在 go mod init 命令启动时初始化。\n// src/cmd/go/internal/modcmd/init.go func runInit(cmd *base.Command, args []string) { modload.CmdModInit = true if len(args) \u0026gt; 1 { base.Fatalf(\u0026#34;go mod init: too many arguments\u0026#34;) } if len(args) == 1 { modload.CmdModModule = args[0] // INITIALIZATION IS HERE!  } if _, err := os.Stat(\u0026#34;go.mod\u0026#34;); err == nil { base.Fatalf(\u0026#34;go mod init: go.mod already exists\u0026#34;) } modload.InitMod() // does all the hard work } 因此，由于 string 类型变量的 empty value 是空字符串，所以每次使运行 go mod edit -module a/new/module/name 并不会把 module path 修改为 a/new/module/name，而是修改为空字符串。\n$ go mod init github.com/ziyi-yan/hello go: creating new go.mod: module github.com/ziyi-yan/hello $ cat go.mod module github.com/ziyi-yan/hello $ go mod edit -module github.com/ziyi-yan/hello-new $ cat go.mod module \u0026quot;\u0026quot;  go 语言最新的代码 已经修复了这个 bug，预计在 Go 1.12 中发布。\n","title":"第 24 期 go mod 源码阅读 part 1"},{"location":"http://bytemode.github.io/reading/23-2018-12-13-drone-guide/","text":" 观看视频   参考资料  基于 gogs/gitlab 和 drone 搭建的 CI/CD 平台 Drone 源码分析之同步 repos 的策略研讨 Drone 源码分析之数据库初始化  ","title":"第 23 期 Drone 简单介绍和部分源码分析"},{"location":"http://bytemode.github.io/reading/22-2018-12-06-go-ide-discuss/","text":" 观看视频   ","title":"第 22 期 Go 开发工具讨论"},{"location":"http://bytemode.github.io/reading/21-2018-11-28-errors-in-go/","text":" 观看视频   ","title":"第 21 期 Go errors 处理及 zap 源码分析"},{"location":"http://bytemode.github.io/reading/20-2018-11-15-go-test/","text":" 观看视频   ","title":"第 20 期 go test 及测试覆盖率"},{"location":"http://bytemode.github.io/","text":"         \nStargazers over time \nreading-go Star History and Stats\nGo 学习与分享：\n Go 夜读  *根据【草案】Go 夜读重大调整(请每个人都来说说你的看法和意见），我们将按计划进行 Go 源码阅读或者 Go 项目实践，你如果是 Go 新手可以先去这里看看 Go 学习之路。* \u0026gt;范畴：Go 标准包、开源项目、Go 项目最佳实践等。\n 每日一问\n Go 项目实践\n Gin 开发 [goim 开发(todo)]()  TiDB 源码学习（从6月5日开始，每周三晚上21点 zoom live ）：\n TiDB 源码概览； 执行引擎； 优化器； 事务； 其他（工程化，测试等）；   阅读清单 strings strconv testing net/http sync flag etcd/raft defer context golang/sync kubernetes  回看地址  Go 夜读(YouTuBe) Go 夜读(B 站)  我们的目标 我们希望可以推进大家深入了解 Go ，快速成长为资深的 Gopher 。我们希望每次来了的人和没来的人都能够有收获，成长。\n我们的方式 由一个主讲人带着大家一起去阅读 Go 源代码，一起去啃那些难啃的算法、学习代码里面的奇淫技巧，遇到问题或者有疑惑了，我们可以一起去检索，解答这些问题。我们可以一起学习，共同成长。\n 阅读规则：选取 package 包，然后从上往下开始读 xxx.go 文件，每个文件从上往下读导出的函数（一步一步跟逻辑，如果逻辑跳出这个 package 则不做深入探究）。\n 我们的精神 开源！开源！开源！重要的事，一定要说三遍。\n 希望有兴趣的小伙伴们一起加入，让我们一起把 《Go 夜读》建立成一个对大家都有帮助的开源社区。\n 怎么加入 如果你想加入微信群，请搜索 mai_yang ，然后备注你的姓名、公司、工作岗位和职责，备注来源：Github。\n有同学想要用 Slack 交流，我开放了一个：reading-go Slack\n如何参与贡献？ ├── reading // Go 源码阅读 ├── discuss // 日常微信群讨论的总结 ├── articles // 个人原创的技术文章 ├── interview // Go 面试专区 └── other // 其他 如何参与贡献\nContributors 我非常重视每一个对这个项目的贡献者，我会将贡献者列表更新到这里，目前只有提交 Pull Request 的小伙伴，但是贡献不仅仅如此，还可以包括提交 Issue 以及在社群中有所贡献的人。\n贡献者自己可以提 PR ，方法如下：\n 安装 npm install -g --save-dev all-contributors-cli sh gen_contributors.sh  Thanks goes to these wonderful people (emoji key):\n   maiyang\n💻 🤔 👀 📢 ✅ Simple Min\n💻 kenny\n💻 charnlsxy\n💻 AceDarkknight\n💻 Data\n💻 侯名\n💻     dumliu01\n💻 hlily2005\n💻 fenggolang\n💻 henrylee2cn\n💻 shaqsnake\n💻 tbwisk\n💻 Huang ChuanTong\n💻   The notes of SQL optimize \n💻 zhouxinxin19920802\n💻 macaria\n💻 Dennis\n💻 orangleliu\n💻 HarbinZhang\n💻 LiMingji\n💻   wintersnow\n💻 zhuzhenfeng\n💻 徐佳军\n💻 nicho\n💻 Weifeng Wang\n💻 John Deng\n💻     This project follows the all-contributors specification. Contributions of any kind welcome!\n","title":"Go 夜读"},{"location":"http://bytemode.github.io/reading/19-2018-11-08-http-router-in-go/","text":" 观看视频   ","title":"第 19 期 如何开发一个简单高性能的http router及gorouter源码分析"},{"location":"http://bytemode.github.io/reading/18-2018-09-27-covenantsql-dh-rpc/","text":" 观看视频   ","title":"第 18 期 去中心化加密通信框架 CovenantSQL/DH-RPC的设计"},{"location":"http://bytemode.github.io/reading/17-2018-09-20-grpcp/","text":" 观看视频   ","title":"第 17 期 grpc 开发及 grpcp 的源码分析"},{"location":"http://bytemode.github.io/reading/16-2018-09-06-gateway-reading/","text":" OpenFaaS的Gateway是一个golang实现的请求转发的网关，在这个网关服务中，主要有以下几个功能：\n UI 部署函数 监控 自动伸缩  架构分析 从图中可以发现，当Gateway作为一个入口，当CLI或者web页面发来要部署或者调用一个函数的时候，Gateway会将请求转发给Provider，同时会将监控指标发给Prometheus。AlterManager会根据需求，调用API自动伸缩函数。\n源码分析 依赖 github.com/gorilla/mux github.com/nats-io/go-nats-streaming github.com/nats-io/go-nats github.com/openfaas/nats-queue-worker github.com/prometheus/client_golang mux 是一个用来执行http请求的路由和分发的第三方扩展包。\ngo-nats-streaming，go-nats，nats-queue-worker这三个依赖是异步函数的时候才会用到，在分析queue-worker的时候有说到Gateway也是一个发布者。\nclient_golang是Prometheus的客户端。\n项目结构 ├── Dockerfile ├── Dockerfile.arm64 ├── Dockerfile.armhf ├── Gopkg.lock ├── Gopkg.toml ├── README.md ├── assets ├── build.sh ├── handlers │ ├── alerthandler.go │ ├── alerthandler_test.go │ ├── asyncreport.go │ ├── baseurlresolver_test.go │ ├── basic_auth.go │ ├── basic_auth_test.go │ ├── callid_middleware.go │ ├── cors.go │ ├── cors_test.go │ ├── forwarding_proxy.go │ ├── forwarding_proxy_test.go │ ├── function_cache.go │ ├── function_cache_test.go │ ├── infohandler.go │ ├── metrics.go │ ├── queueproxy.go │ ├── scaling.go │ └── service_query.go ├── metrics │ ├── add_metrics.go │ ├── add_metrics_test.go │ ├── externalwatcher.go │ ├── metrics.go │ └── prometheus_query.go ├── plugin │ ├── external.go │ └── external_test.go ├── queue │ └── types.go ├── requests │ ├── forward_request.go │ ├── forward_request_test.go │ ├── prometheus.go │ ├── prometheus_test.go │ └── requests.go ├── server.go ├── tests │ └── integration ├── types │ ├── handler_set.go │ ├── inforequest.go │ ├── load_credentials.go │ ├── proxy_client.go │ ├── readconfig.go │ └── readconfig_test.go ├── vendor │ └── github.com └── version └── version.go Gateway的目录明显多了很多，看源码的时候，首先要找到的是main包，从main函数看起，就能很容易分析出来项目是如何运行的。\n从server.go的main函数中我们可以看到，其实有如下几个模块：\n 基本的安全验证 和函数相关的代理转发  同步函数 列出函数 部署函数 删除函数 更新函数 异步函数  Prometheus的监控 ui 自动伸缩  基本的安全验证 如果配置了开启基本安全验证，会从磁盘中读取密钥：\nvar credentials *types.BasicAuthCredentials if config.UseBasicAuth { var readErr error reader := types.ReadBasicAuthFromDisk{ SecretMountPath: config.SecretMountPath, } credentials, readErr = reader.Read() if readErr != nil { log.Panicf(readErr.Error()) } } 在Gateway的配置相关的，都会有一个read()方法，进行初始化赋值。\n如果credentials被赋值之后，就会对一些要加密的API handler进行一个修饰，被修饰的API有：\n UpdateFunction DeleteFunction DeployFunction ListFunctions ScaleFunction  if credentials != nil { faasHandlers.UpdateFunction = handlers.DecorateWithBasicAuth(faasHandlers.UpdateFunction, credentials) faasHandlers.DeleteFunction = handlers.DecorateWithBasicAuth(faasHandlers.DeleteFunction, credentials) faasHandlers.DeployFunction = handlers.DecorateWithBasicAuth(faasHandlers.DeployFunction, credentials) faasHandlers.ListFunctions = handlers.DecorateWithBasicAuth(faasHandlers.ListFunctions, credentials) faasHandlers.ScaleFunction = handlers.DecorateWithBasicAuth(faasHandlers.ScaleFunction, credentials) } 这个DecorateWithBasicAuth()方法是一个路由中间件：\n 调用mux路由的BasicAuth()，从http的header中取到用户名和密码 然后给请求头上设置一个字段WWW-Authenticate，值为Basic realm=\u0026quot;Restricted\u0026quot; 如果校验失败，则返回错误，成功的话调用next方法继续进入下一个handler。  // DecorateWithBasicAuth enforces basic auth as a middleware with given credentials func DecorateWithBasicAuth(next http.HandlerFunc, credentials *types.BasicAuthCredentials) http.HandlerFunc { return func(w http.ResponseWriter, r *http.Request) { user, password, ok := r.BasicAuth() w.Header().Set(\u0026#34;WWW-Authenticate\u0026#34;, `Basic realm=\u0026#34;Restricted\u0026#34;`) if !ok || !(credentials.Password == password \u0026amp;\u0026amp; user == credentials.User) { w.WriteHeader(http.StatusUnauthorized) w.Write([]byte(\u0026#34;invalid credentials\u0026#34;)) return } next.ServeHTTP(w, r) } } 代理转发 Gateway本身不做任何和部署发布函数的事情，它只是作为一个代理，把请求转发给相应的Provider去处理，所有的请求都要通过这个网关。\n同步函数转发 主要转发的API有：\n RoutelessProxy ListFunctions DeployFunction DeleteFunction UpdateFunction  faasHandlers.RoutelessProxy = handlers.MakeForwardingProxyHandler(reverseProxy, forwardingNotifiers, urlResolver) faasHandlers.ListFunctions = handlers.MakeForwardingProxyHandler(reverseProxy, forwardingNotifiers, urlResolver) faasHandlers.DeployFunction = handlers.MakeForwardingProxyHandler(reverseProxy, forwardingNotifiers, urlResolver) faasHandlers.DeleteFunction = handlers.MakeForwardingProxyHandler(reverseProxy, forwardingNotifiers, urlResolver) faasHandlers.UpdateFunction = handlers.MakeForwardingProxyHandler(reverseProxy, forwardingNotifiers, urlResolver) MakeForwardingProxyHandler()有三个参数：\n proxy  这是一个http的客户端，作者把这个客户端抽成一个类，然后使用该类的NewHTTPClientReverseProxy方法创建实例，这样就简化了代码，不用每次都得写一堆相同的配置。\n notifiers  这个其实是要打印的日志，这里是一个HTTPNotifier的接口。而在这个MakeForwardingProxyHandler中其实有两个实现类，一个是LoggingNotifier，一个是PrometheusFunctionNotifier，分别用来打印和函数http请求相关的日志以及和Prometheus监控相关的日志。\n baseURLResolver  这个就是Provider的url地址。\n在这个MakeForwardingProxyHandler中主要做了三件事儿：\n 解析要转发的url\n 调用forwardRequest方法转发请求，\n  forwardRequest方法的逻辑比较简单，只是把请求发出去。这里就不深入分析了。\n 打印日志  // MakeForwardingProxyHandler create a handler which forwards HTTP requests func MakeForwardingProxyHandler(proxy *types.HTTPClientReverseProxy, notifiers []HTTPNotifier, baseURLResolver BaseURLResolver) http.HandlerFunc { return func(w http.ResponseWriter, r *http.Request) { baseURL := baseURLResolver.Resolve(r) requestURL := r.URL.Path start := time.Now() statusCode, err := forwardRequest(w, r, proxy.Client, baseURL, requestURL, proxy.Timeout) seconds := time.Since(start) if err != nil { log.Printf(\u0026#34;error with upstream request to: %s, %s\\n\u0026#34;, requestURL, err.Error()) } for _, notifier := range notifiers { notifier.Notify(r.Method, requestURL, statusCode, seconds) } } } 异步函数转发 前面说过，如果是异步函数，Gateway就作为一个发布者，将函数放到队列里。MakeQueuedProxy方法就是做这件事儿的：\n 读取请求体 将X-Callback-Url参数从参数中http的header中读出来 实例化用于异步处理的Request对象 调用canQueueRequests.Queue(req)，将请求发布到队列中  // MakeQueuedProxy accepts work onto a queue func MakeQueuedProxy(metrics metrics.MetricOptions, wildcard bool, canQueueRequests queue.CanQueueRequests) http.HandlerFunc { return func(w http.ResponseWriter, r *http.Request) { defer r.Body.Close() body, err := ioutil.ReadAll(r.Body) // 省略错误处理代码  vars := mux.Vars(r) name := vars[\u0026#34;name\u0026#34;] callbackURLHeader := r.Header.Get(\u0026#34;X-Callback-Url\u0026#34;) var callbackURL *url.URL if len(callbackURLHeader) \u0026gt; 0 { urlVal, urlErr := url.Parse(callbackURLHeader) // 省略错误处理代码  callbackURL = urlVal } req := \u0026amp;queue.Request{ Function: name, Body: body, Method: r.Method, QueryString: r.URL.RawQuery, Header: r.Header, CallbackURL: callbackURL, } err = canQueueRequests.Queue(req) // 省略错误处理代码  w.WriteHeader(http.StatusAccepted) } } 自动伸缩 伸缩性其实有两种，一种是可以通过调用API接口，来将函数进行缩放。另外一种就是通过AlertHandler。\n自动伸缩是OpenFaaS的一大特点，触发自动伸缩主要是根据不同的指标需求。\n 根据每秒请求数来做伸缩  OpenFaaS附带了一个自动伸缩的规则，这个规则是在AlertManager配置文件中定义。AlertManager从Prometheus中读取使用情况（每秒请求数），然后在满足一定条件时向Gateway发送警报。\n可以通过删除AlertManager，或者将部署扩展的环境变量设置为0，来禁用此方式。\n 最小/最大副本数  通过向函数添加标签, 可以在部署时设置最小 (初始) 和最大副本数。\n com.openfaas.scale.min 默认是 1 com.openfaas.scale.max 默认是 20 com.openfaas.scale.factor 默认是 20% ，在0-100之间，这是每次扩容的时候，新增实例的百分比，若是100的话，会瞬间飙升到副本数的最大值。  com.openfaas.scale.min 和 com.openfaas.scale.max值一样的时候，可以关闭自动伸缩。\ncom.openfaas.scale.factor是0时，也会关闭自动伸缩。\n 通过内存和CPU的使用量。  使用k8s内置的HPA，也可以触发AlertManager。\n手动指定伸缩的值 可以从这句代码中发现，调用这个路由，转发给了provider处理。\nr.HandleFunc(\u0026quot;/system/scale-function/{name:[-a-zA-Z_0-9]+}\u0026quot;, faasHandlers.ScaleFunction).Methods(http.MethodPost)  处理AlertManager的伸缩请求 Prometheus将监控指标发给AlertManager之后，会触发AlterManager调用/system/alert接口，这个接口的handler是由handlers.MakeAlertHandler方法生成。\nMakeAlertHandler方法接收的参数是ServiceQuery。ServiceQuery是一个接口，它有两个函数，用来get或者ser最大的副本数。Gateway中实现这个接口的类是ExternalServiceQuery，这个实现类是在plugin包中，我们也可以直接定制这个实现类，用来实现满足特定条件。\n// ServiceQuery provides interface for replica querying/setting type ServiceQuery interface { GetReplicas(service string) (response ServiceQueryResponse, err error) SetReplicas(service string, count uint64) error } // ExternalServiceQuery proxies service queries to external plugin via HTTP type ExternalServiceQuery struct { URL url.URL ProxyClient http.Client } 这个ExternalServiceQuery有一个NewExternalServiceQuery方法，这个方法也是一个工厂方法，用来创建实例。这个url其实就是provider的url，proxyClient就是一个http的client对象。\n GetReplicas方法  从system/function/:name接口获取到函数的信息，组装一个ServiceQueryResponse对象即可。\n SetReplicas方法  调用system/scale-function/:name接口，设置副本数。\nMakeAlertHandler的函数主要是从http.Request中读取body，然后反序列化成PrometheusAlert对象：\n// PrometheusAlert as produced by AlertManager type PrometheusAlert struct { Status string `json:\u0026#34;status\u0026#34;` Receiver string `json:\u0026#34;receiver\u0026#34;` Alerts []PrometheusInnerAlert `json:\u0026#34;alerts\u0026#34;` } 可以发现，这个Alerts是一个数组对象，所以可以是对多个函数进行缩放。反序列化之后，调用handleAlerts方法，而handleAlerts对Alerts进行遍历，针对每个Alerts调用了scaleService方法。scaleService才是真正处理伸缩服务的函数。\nfunc scaleService(alert requests.PrometheusInnerAlert, service ServiceQuery) error { var err error serviceName := alert.Labels.FunctionName if len(serviceName) \u0026gt; 0 { queryResponse, getErr := service.GetReplicas(serviceName) if getErr == nil { status := alert.Status newReplicas := CalculateReplicas(status, queryResponse.Replicas, uint64(queryResponse.MaxReplicas), queryResponse.MinReplicas, queryResponse.ScalingFactor) log.Printf(\u0026#34;[Scale] function=%s %d =\u0026gt; %d.\\n\u0026#34;, serviceName, queryResponse.Replicas, newReplicas) if newReplicas == queryResponse.Replicas { return nil } updateErr := service.SetReplicas(serviceName, newReplicas) if updateErr != nil { err = updateErr } } } return err } 从代码总就可以看到，scaleService做了三件事儿：\n 获取现在的副本数\n 计算新的副本数\n  新副本数的计算方法是根据com.openfaas.scale.factor计算步长：\nstep := uint64((float64(maxReplicas) / 100) * float64(scalingFactor))  设置为新的副本数  从0增加副本到的最小值 我们在调用函数的时候，用的路由是：/function/:name。如果环境变量里有配置scale_from_zero为true，先用MakeScalingHandler()方法对proxyHandler进行一次包装。\nMakeScalingHandler接受参数主要是：\n next：就是下一个httpHandlerFunc，中间件都会有这样一个参数\n config：ScalingConfig的对象：\n  // ScalingConfig for scaling behaviours  type ScalingConfig struct { MaxPollCount uint // 查到的最大数量  FunctionPollInterval time.Duration // 函数调用时间间隔  CacheExpiry time.Duration // 缓存过期时间  ServiceQuery ServiceQuery // 外部服务调用的一个接口  } 这个MakeScalingHandler中间件主要做了如下的事情：\n 先从FunctionCache缓存中获取该函数的基本信息，从这个缓存可以拿到每个函数的副本数量。 为了加快函数的启动速度，如果缓存中可以获该得函数，且函数的副本数大于0，满足条件，return即可。 如果不满足上一步，就会调用SetReplicas方法设置副本数，并更新FunctionCache的缓存。  // MakeScalingHandler creates handler which can scale a function from // zero to 1 replica(s). func MakeScalingHandler(next http.HandlerFunc, upstream http.HandlerFunc, config ScalingConfig) http.HandlerFunc { cache := FunctionCache{ Cache: make(map[string]*FunctionMeta), Expiry: config.CacheExpiry, } return func(w http.ResponseWriter, r *http.Request) { functionName := getServiceName(r.URL.String()) if serviceQueryResponse, hit := cache.Get(functionName); hit \u0026amp;\u0026amp; serviceQueryResponse.AvailableReplicas \u0026gt; 0 { next.ServeHTTP(w, r) return } queryResponse, err := config.ServiceQuery.GetReplicas(functionName) cache.Set(functionName, queryResponse) // 省略错误处理  if queryResponse.AvailableReplicas == 0 { minReplicas := uint64(1) if queryResponse.MinReplicas \u0026gt; 0 { minReplicas = queryResponse.MinReplicas } err := config.ServiceQuery.SetReplicas(functionName, minReplicas) // 省略错误处理代码  for i := 0; i \u0026lt; int(config.MaxPollCount); i++ { queryResponse, err := config.ServiceQuery.GetReplicas(functionName) cache.Set(functionName, queryResponse) // 省略错误处理  time.Sleep(config.FunctionPollInterval) } } next.ServeHTTP(w, r) } } 监控 监控是一个定时任务，开启了一个新协程，利用go的ticker.C的间隔不停的去调用/system/functions接口。反序列化到MetricOptions对象中。\nfunc AttachExternalWatcher(endpointURL url.URL, metricsOptions MetricOptions, label string, interval time.Duration) { ticker := time.NewTicker(interval) quit := make(chan struct{}) proxyClient := // 省略创建一个http.Client对象  go func() { for { select { case \u0026lt;-ticker.C: get, _ := http.NewRequest(http.MethodGet, endpointURL.String()+\u0026#34;system/functions\u0026#34;, nil) services := []requests.Function{} res, err := proxyClient.Do(get) // 省略反序列的代码  for _, service := range services { metricsOptions.ServiceReplicasCounter. WithLabelValues(service.Name). Set(float64(service.Replicas)) } break case \u0026lt;-quit: return } } }() } UI UI的代码很简单，主要就是一些前端的代码，调用上面的讲的一些API接口即可，这里就略去不表。\n总结 Gateway是OpenFaaS最为重要的一个组件。回过头看整个项目的结构，Gateway就是一个rest转发服务，一个一个的handler，每个模块之间的耦合性不是很高，可以很容易的去拆卸，自定义实现相应的模块。\n","title":"第 16 期 gateway-reading"},{"location":"http://bytemode.github.io/reading/15-2018-08-23-pool-workshop-in-go/","text":"  2018-08-23 22:00:00 分享会之后的答疑。\n 源代码地址：pool#workshop\n一个网友在分享会之后的个人理解：对是独占资源对象的复用，提升了最后的 qps，独占式方法 TestChanPool() 函数中使用了从资源池获取 worker 对象，执行完毕后再放回资源池，如果获取不到则阻塞等待，因此，100 000 请求，每个请求占用 10ms，可用 worker 对象 50 个，则最后 100 000*10/50 =20s ,视频中测试结果也显示 21s 符合预期。而 TestWorkshop() 函数中使用回调函数对 worker 进行加锁，每个线程使用的那一刻是 worker 对象是被独占的，而后续的 do{sleep(10ms)} 是并发执行的，并且根据每个 worker 同时执行的 do 的任务数，进行负载均衡，所以最后测试性能 QPS 能够有 20 倍的提升。\n workshop 中每个协程只在获得 worker 的那一刻是互斥的，且不会从池子中移除，通过状态统计达到资源的负载均衡。在业务上真正使用资源时其实是无锁状态，所以能被其他协程同时使用，进而吞吐量提升。业务逻辑耗时越长，相比独占式资源池的吞吐量优势越显著。本机测试 50 个资源 10ms 时可提升 20 倍。\n 为什么不使用轮询使用资源，代码实现会更简单？  实际场景中每次业务逻辑耗时不相同，轮询并不能保证真的负载均衡。尤其是当突发异常时，可能导致负载失衡。\n 为什么长连接异步通信不使用一条连接而是连接池？ 说到长连接异步通信，为什么不使用一条连接而是连接池，其实涉及到多条连接抢占带宽和 TCP 丢包后速率下降的问题。这对于下载场景（迅雷就是这么做的）和使用共享云主机的场景比较有用。 具体可以看这篇文章：为什么多 TCP 连接比单TCP连接传输快\n 以前在做加速的一项就是多线程下载，开启多个 tcp 连接，同时下载，比只有一个连接下载快多了。\n workshop 的使用场景 使用 workshop 的前提就是该资源可以被同时使用，比如长连接的异步IO通信。\n对于长连接异步通信时，如果使用了独占式连接池只会起到反效果，让它和同步通信没差别，还不如不用池子。workshop 就是适用于这个场景的。\n长连接：同步和异步方式。 同步方式下客户端所有请求共用同一连接，在获得连接后要对连接加锁，在读写结束后才解锁释放连接，性能低下，基本很少采用，唯一优点是实现极其简单。\n异步方式下所有请求都带有消息ID，因此可以批量发送请求，异步接收回复，所有请求和回复的消息都共享同一连接，信道得到最大化利用，因此吞吐量最大。\n这个时候接收端的处理能力也要求比较高，一般都是独立的一个（或者多个）收包线程（或者进程）防止内核缓冲区被填满影响网络吞吐量。缺点是实现复杂，需要异步状态机，需要增加负载均衡和连接健康度检测机制，等等。\nworkshop 就是实现了上述多条异步连接间的负载均衡，健康检测等。\n观看视频   参考资料  为什么多 TCP 连接比单TCP连接传输快  ","title":"第 15 期 多路复用资源池组件剖析"},{"location":"http://bytemode.github.io/reading/14-2018-08-17-sync-pool-reading/","text":" Go 标准包阅读\n观看视频   ","title":"第 14 期 sync.Pool 源码分析及适用场景"},{"location":"http://bytemode.github.io/reading/13-2018-08-09-kubernetes-guide/","text":" 观看视频   ","title":"第 13 期 Kubernetes 入门指南"},{"location":"http://bytemode.github.io/reading/12-2018-08-02-goroutine-gpm/","text":" 郑宝杨(boya) 2018-08-01 listomebao@gmail.com\n阅读源码前可以阅读的资料  Goroutine背后的系统知识 golang源码剖析-雨痕老师 go-intervals 也谈goroutine调度器  golang的调度模型概览 调度的机制用一句话描述：\nruntime准备好G,P,M，然后M绑定P，M从各种队列中获取G，切换到G的执行栈上并执行G上的任务函数，调用goexit做清理工作并回到M，如此反复。\n基本概念 M（machine）  M代表着真正的执行计算资源，可以认为它就是os thread（系统线程）。 M是真正调度系统的执行者，每个M就像一个勤劳的工作者，总是从各种队列中找到可运行的G，而且这样M的可以同时存在多个。 M在绑定有效的P后，进入调度循环，而且M并不保留G状态，这是G可以跨M调度的基础。  P（processor）  P表示逻辑processor，是线程M的执行的上下文。 P的最大作用是其拥有的各种G对象队列、链表、cache和状态。  G（goroutine）  调度系统的最基本单位goroutine，存储了goroutine的执行stack信息、goroutine状态以及goroutine的任务函数等。 在G的眼中只有P，P就是运行G的“CPU”。 相当于两级线程  线程实现模型 来自Go并发编程实战\n +-------+ +-------+ | KSE | | KSE | +-------+ +-------+ | | 内核空间 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - | | 用户空间 +-------+ +-------+ | M | | M | +-------+ +-------+ | | | | +------+ +------+ +------+ +------+ | P | | P | | P | | P | +------+ +------+ +------+ +------+ | | | | | | | | | +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ | G | | G | | G | | G | | G | | G | | G | | G | | G | +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---+   KSE（Kernel Scheduling Entity）是内核调度实体\n M与P，P与G之前的关联都是动态的，可以变的  关系示意图 来自golang源码剖析\n +-------------------- sysmon ---------------//------+ | | | | +---+ +---+-------+ +--------+ +---+---+ go func() ---\u0026gt; | G | ---\u0026gt; | P | local | \u0026lt;=== balance ===\u0026gt; | global | \u0026lt;--//--- | P | M | +---+ +---+-------+ +--------+ +---+---+ | | | | +---+ | | +----\u0026gt; | M | \u0026lt;--- findrunnable ---+--- steal \u0026lt;--//--+ +---+ | mstart | +--- execute \u0026lt;----- schedule | | | | +--\u0026gt; G.fn --\u0026gt; goexit --+ 1. go func() 语气创建G。 2. 将G放入P的本地队列（或者平衡到全局全局队列）。 3. 唤醒或新建M来执行任务。 4. 进入调度循环 5. 尽力获取可执行的G，并执行 6. 清理现场并且重新进入调度循环  GPM的来由 特殊的g0和m0 g0和m0是在proc.go文件中的两个全局变量，m0就是进程启动后的初始线程，g0也是代表着初始线程的stack\nasm_amd64.go \u0026ndash;\u0026gt; runtime·rt0_go(SB)\n// 程序刚启动的时候必定有一个线程启动（主线程）  // 将当前的栈和资源保存在g0  // 将该线程保存在m0  // tls: Thread Local Storage  // set the per-goroutine and per-mach \u0026#34;registers\u0026#34;  get_tls(BX) LEAQ runtime·g0(SB), CX MOVQ CX, g(BX) LEAQ runtime·m0(SB), AX // save m-\u0026gt;g0 = g0  MOVQ CX, m_g0(AX) // save m0 to g0-\u0026gt;m  MOVQ AX, g_m(CX) M的一生 M的创建 proc.go\n// Create a new m. It will start off with a call to fn, or else the scheduler. // fn needs to be static and not a heap allocated closure. // May run with m.p==nil, so write barriers are not allowed. //go:nowritebarrierrec // 创建一个新的m，它将从fn或者调度程序开始 func newm(fn func(), _p_ *p) { // 根据fn和p和绑定一个m对象  mp := allocm(_p_, fn) // 设置当前m的下一个p为_p_  mp.nextp.set(_p_) mp.sigmask = initSigmask ... // 真正的分配os thread  newm1(mp) }func newm1(mp *m) { // 对cgo的处理  ... execLock.rlock() // Prevent process clone.  // 创建一个系统线程  newosproc(mp, unsafe.Pointer(mp.g0.stack.hi)) execLock.runlock() } 状态  mstart | v 找不到可执行任务，gc STW， +------+ 任务执行时间过长，系统阻塞等 +------+ | spin | ----------------------------\u0026gt; |unspin| +------+ mstop +------+ ^ | | v notewakeup \u0026lt;------------------------- notesleep  M的一些问题 https://github.com/golang/go/issues/14592\nP的一生 P的创建 proc.go\n// Change number of processors. The world is stopped, sched is locked. // gcworkbufs are not being modified by either the GC or // the write barrier code. // Returns list of Ps with local work, they need to be scheduled by the caller. // 所有的P都在这个函数分配，不管是最开始的初始化分配，还是后期调整 func procresize(nprocs int32) *p { old := gomaxprocs // 如果 gomaxprocs \u0026lt;=0 抛出异常  if old \u0026lt; 0 || nprocs \u0026lt;= 0 { throw(\u0026#34;procresize: invalid arg\u0026#34;) } ... // Grow allp if necessary.  if nprocs \u0026gt; int32(len(allp)) { // Synchronize with retake, which could be running  // concurrently since it doesn\u0026#39;t run on a P.  lock(\u0026amp;allpLock) if nprocs \u0026lt;= int32(cap(allp)) { allp = allp[:nprocs] } else { // 分配nprocs个*p  nallp := make([]*p, nprocs) // Copy everything up to allp\u0026#39;s cap so we  // never lose old allocated Ps.  copy(nallp, allp[:cap(allp)]) allp = nallp } unlock(\u0026amp;allpLock) } // initialize new P\u0026#39;s  for i := int32(0); i \u0026lt; nprocs; i++ { pp := allp[i] if pp == nil { pp = new(p) pp.id = i pp.status = _Pgcstop // 更改状态  pp.sudogcache = pp.sudogbuf[:0] //将sudogcache指向sudogbuf的起始地址  for i := range pp.deferpool { pp.deferpool[i] = pp.deferpoolbuf[i][:0] } pp.wbBuf.reset() // 将pp保存到allp数组里, allp[i] = pp  atomicstorep(unsafe.Pointer(\u0026amp;allp[i]), unsafe.Pointer(pp)) } ... } ... _g_ := getg() // 如果当前的M已经绑定P，继续使用，否则将当前的M绑定一个P  if _g_.m.p != 0 \u0026amp;\u0026amp; _g_.m.p.ptr().id \u0026lt; nprocs { // continue to use the current P  _g_.m.p.ptr().status = _Prunning } else { // release the current P and acquire allp[0]  // 获取allp[0]  if _g_.m.p != 0 { _g_.m.p.ptr().m = 0 } _g_.m.p = 0 _g_.m.mcache = nil p := allp[0] p.m = 0 p.status = _Pidle // 将当前的m和p绑定  acquirep(p) if trace.enabled { traceGoStart() } } var runnablePs *p for i := nprocs - 1; i \u0026gt;= 0; i-- { p := allp[i] if _g_.m.p.ptr() == p { continue } p.status = _Pidle if runqempty(p) { // 将空闲p放入空闲链表  pidleput(p) } else { p.m.set(mget()) p.link.set(runnablePs) runnablePs = p } } stealOrder.reset(uint32(nprocs)) var int32p *int32 = \u0026amp;gomaxprocs // make compiler check that gomaxprocs is an int32  atomic.Store((*uint32)(unsafe.Pointer(int32p)), uint32(nprocs)) return runnablePs } 所有的P在程序启动的时候就设置好了，并用一个allp slice维护，可以调用runtime.GOMAXPROCS调整P的个数，虽然代价很大\n状态转换  acquirep(p) 不需要使用的P P和M绑定的时候 进入系统调用 procresize() new(p) -----+ +---------------+ +-----------+ +------------+ +----------+ | | | | | | | | | | +------------+ +---v--------+ +---v--------+ +----v-------+ +--v---------+ +--\u0026gt;| _Pgcstop | | _Pidle | | _Prunning | | _Psyscall | | _Pdead | +------^-----+ +--------^---+ +--------^---+ +------------+ +------------+ | | | | | | +------------+ +------------+ +------------+ GC结束 releasep() 退出系统调用 P和M解绑  P的数量默认等于cpu的个数，很多人认为runtime.GOMAXPROCS可以限制系统线程的数量，但这是错误的，M是按需创建的，和runtime.GOMAXPROCS没有关系。\nG的一生 G的创建 proc.go\n// Create a new g running fn with siz bytes of arguments. // Put it on the queue of g\u0026#39;s waiting to run. // The compiler turns a go statement into a call to this. // Cannot split the stack because it assumes that the arguments // are available sequentially after \u0026amp;fn; they would not be // copied if a stack split occurred. //go:nosplit // 新建一个goroutine， // 􏳄 用fn + PtrSize 获取第一个参数的地址，也就是argp // 用siz - 8 获取pc地址 func newproc(siz int32, fn *funcval) { argp := add(unsafe.Pointer(\u0026amp;fn), sys.PtrSize) pc := getcallerpc() // 用g0的栈创建G对象  systemstack(func() { newproc1(fn, (*uint8)(argp), siz, pc) }) }// Create a new g running fn with narg bytes of arguments starting // at argp. callerpc is the address of the go statement that created // this. The new g is put on the queue of g\u0026#39;s waiting to run. // 根据函数参数和函数地址，创建一个新的G，然后将这个G加入队列等待运行 func newproc1(fn *funcval, argp *uint8, narg int32, callerpc uintptr) { _g_ := getg() if fn == nil { _g_.m.throwing = -1 // do not dump full stacks  throw(\u0026#34;go of nil func value\u0026#34;) } _g_.m.locks++ // disable preemption because it can be holding p in a local var  siz := narg siz = (siz + 7) \u0026amp;^ 7 // We could allocate a larger initial stack if necessary.  // Not worth it: this is almost always an error.  // 4*sizeof(uintreg): extra space added below  // sizeof(uintreg): caller\u0026#39;s LR (arm) or return address (x86, in gostartcall).  // 如果函数的参数大小比2048大的话，直接panic  if siz \u0026gt;= _StackMin-4*sys.RegSize-sys.RegSize { throw(\u0026#34;newproc: function arguments too large for new goroutine\u0026#34;) } // 从m中获取p  _p_ := _g_.m.p.ptr() // 从gfree list获取g  newg := gfget(_p_) // 如果没获取到g，则新建一个  if newg == nil { newg = malg(_StackMin) casgstatus(newg, _Gidle, _Gdead) //将g的状态改为_Gdead  // 添加到allg数组，防止gc扫描清除掉  allgadd(newg) // publishes with a g-\u0026gt;status of Gdead so GC scanner doesn\u0026#39;t look at uninitialized stack.  } if newg.stack.hi == 0 { throw(\u0026#34;newproc1: newg missing stack\u0026#34;) } if readgstatus(newg) != _Gdead { throw(\u0026#34;newproc1: new g is not Gdead\u0026#34;) } totalSize := 4*sys.RegSize + uintptr(siz) + sys.MinFrameSize // extra space in case of reads slightly beyond frame  totalSize += -totalSize \u0026amp; (sys.SpAlign - 1) // align to spAlign  sp := newg.stack.hi - totalSize spArg := sp if usesLR { // caller\u0026#39;s LR  *(*uintptr)(unsafe.Pointer(sp)) = 0 prepGoExitFrame(sp) spArg += sys.MinFrameSize } if narg \u0026gt; 0 { // copy参数  memmove(unsafe.Pointer(spArg), unsafe.Pointer(argp), uintptr(narg)) // This is a stack-to-stack copy. If write barriers  // are enabled and the source stack is grey (the  // destination is always black), then perform a  // barrier copy. We do this *after* the memmove  // because the destination stack may have garbage on  // it.  if writeBarrier.needed \u0026amp;\u0026amp; !_g_.m.curg.gcscandone { f := findfunc(fn.fn) stkmap := (*stackmap)(funcdata(f, _FUNCDATA_ArgsPointerMaps)) // We\u0026#39;re in the prologue, so it\u0026#39;s always stack map index 0.  bv := stackmapdata(stkmap, 0) bulkBarrierBitmap(spArg, spArg, uintptr(narg), 0, bv.bytedata) } } memclrNoHeapPointers(unsafe.Pointer(\u0026amp;newg.sched), unsafe.Sizeof(newg.sched)) newg.sched.sp = sp newg.stktopsp = sp // 保存goexit的地址到sched.pc  newg.sched.pc = funcPC(goexit) + sys.PCQuantum // +PCQuantum so that previous instruction is in same function  newg.sched.g = guintptr(unsafe.Pointer(newg)) gostartcallfn(\u0026amp;newg.sched, fn) newg.gopc = callerpc newg.startpc = fn.fn if _g_.m.curg != nil { newg.labels = _g_.m.curg.labels } if isSystemGoroutine(newg) { atomic.Xadd(\u0026amp;sched.ngsys, +1) } newg.gcscanvalid = false // 更改当前g的状态为_Grunnable  casgstatus(newg, _Gdead, _Grunnable) if _p_.goidcache == _p_.goidcacheend { // Sched.goidgen is the last allocated id,  // this batch must be [sched.goidgen+1, sched.goidgen+GoidCacheBatch].  // At startup sched.goidgen=0, so main goroutine receives goid=1.  _p_.goidcache = atomic.Xadd64(\u0026amp;sched.goidgen, _GoidCacheBatch) _p_.goidcache -= _GoidCacheBatch - 1 _p_.goidcacheend = _p_.goidcache + _GoidCacheBatch } // 生成唯一的goid  newg.goid = int64(_p_.goidcache) _p_.goidcache++ if raceenabled { newg.racectx = racegostart(callerpc) } if trace.enabled { traceGoCreate(newg, newg.startpc) } // 将当前新生成的g，放入队列  runqput(_p_, newg, true) // 如果有空闲的p 且 m没有处于自旋状态 且 main goroutine已经启动，那么唤醒某个m来执行任务  if atomic.Load(\u0026amp;sched.npidle) != 0 \u0026amp;\u0026amp; atomic.Load(\u0026amp;sched.nmspinning) == 0 \u0026amp;\u0026amp; mainStarted { wakep() } _g_.m.locks-- if _g_.m.locks == 0 \u0026amp;\u0026amp; _g_.preempt { // restore the preemption request in case we\u0026#39;ve cleared it in newstack  _g_.stackguard0 = stackPreempt } } G的状态图  +------------+ ready | | +------------------ | _Gwaiting | | | | | +------------+ | ^ park_m V | +------------+ +------------+ execute +------------+ +------------+ | | newproc | | ---------\u0026gt; | | goexit | | | _Gidle | ---------\u0026gt; | _Grunnable | yield | _Grunning | ---------\u0026gt; | _Gdead | | | | | \u0026lt;--------- | | | | +------------+ +-----^------+ +------------+ +------------+ | entersyscall | ^ | V | existsyscall | +------------+ | existsyscall | | +------------------ | _Gsyscall | | | +------------+  新建的G都是_Grunnable的，新建G的时候优先从gfree list从获取G，这样可以复用G，所以上图的状态不是完整的，_Gdead通过newproc会变为_Grunnable， 通过go func()的语法新建的G，并不是直接运行，而是放入可运行的队列中，什么时候运行用于并不能决定，而是搞调度系统去自发的运行。\n观看视频   ","title":"第 12 期 golang 中 goroutine 的调度"},{"location":"http://bytemode.github.io/reading/11-2018-07-26-golang-jenkins-sonarqube/","text":" 观看视频   ","title":"第 11 期 Golang 代码质量持续检测实践"},{"location":"http://bytemode.github.io/reading/10-2018-06-28-net-http-part4/","text":"  参与人数: 10 人\n Go 标准包阅读  Go版本：go 1.10.2  net包  http/server.go http/request.go textproto/reader.go  读取位置  textproto/reader.go(140行)  问题  1.各个系统的回车换行符区别\n  注意:10.13及其以上是macOS系统   2.URI，URL和URN的区别\n  查看详情   3.HTTP CONNECT方法介绍\n 会议讨论小结\n 可以建立一个代理服务器到目标服务器的透明通道（tcp连接通道），中间完全不会对数据做任何处理，直接转发（支持https，一种翻墙的手段，专线独享）   HTTP代理协议 HTTP/1.1的CONNECT方法   4.peek读取字节内部实现\n  这里先peek获取流数据(注意：这里没有对Peek的错误进行处理，而是根据是否Buffered读取到数据来判断错误) 为什么没有对Peek的错误进行处理呢？主要是因Peek失败了也有可能不会返回错误   golang读取字节表现形式是阻塞式的，但其实底层是用了非阻塞式的NIO，如果没有读取到数据会定时轮询读取   5.http header尾部的符号什么情况下会存在\\n\\n的情况？(待解决，欢迎在下面评论)\n 看源码发现hearder结尾会存在\\r\\n\\r\\n和\\n\\n两种字符情况\n网络上查资料发现只会存在\\r\\n\\r\\n\n观看视频    TODO\n  相关链接  uri和url的详细规范 扒一扒HTTP的构成 20180628直播视频  ","title":"第 10 期 2018-06-28 线下活动"},{"location":"http://bytemode.github.io/reading/9-2018-06-14-net-http-part3/","text":"  参与人数: 12 人\n Go 标准包阅读\nGo 版本：go 1.10.2\nnet/http  server.go h2_bundle.go  问题  WriteHeader(statusCode int)   要先调用 header.set() 再调用 WriteHeader() 然后调用 Write()  如果在调用 Write() 之后，还有比较多的逻辑要处理，则一定要紧跟着马上调一下 Flush()  然后调用 Flush()   HTTP2 不支持 Hijacker\n 使用了 Hijacker 之后不能再使用 Request.Body\n  type Hijacker interface { // After a call to Hijack, the original Request.Body must not be used.  Hijack() (net.Conn, *bufio.ReadWriter, error) }  The returned bufio.Reader may contain unprocessed buffered data from the client.\n CloseNotifier 主要用于 HTTP2\n CloseNotify may wait to notify until Request.Body has been fully read.\n HTTP2 中是如何在 net/http/server.go 中调用 serve() 触发的呢？\n  if proto := c.tlsState.NegotiatedProtocol; validNPN(proto) { if fn := c.server.TLSNextProto[proto]; fn != nil { h := initNPNRequest{tlsConn, serverHandler{c.server}} fn(c.server, tlsConn, h) } return } 主要是 TLSNextProto ，然后查询得到 onceSetNextProtoDefaults() 调用。\n// onceSetNextProtoDefaults configures HTTP/2, if the user hasn\u0026#39;t // configured otherwise. (by setting srv.TLSNextProto non-nil) // It must only be called via srv.nextProtoOnce (use srv.setupHTTP2_*). func (srv *Server) onceSetNextProtoDefaults() { if strings.Contains(os.Getenv(\u0026#34;GODEBUG\u0026#34;), \u0026#34;http2server=0\u0026#34;) { return } // Enable HTTP/2 by default if the user hasn\u0026#39;t otherwise  // configured their TLSNextProto map.  if srv.TLSNextProto == nil { conf := \u0026amp;http2Server{ NewWriteScheduler: func() http2WriteScheduler { return http2NewPriorityWriteScheduler(nil) }, } srv.nextProtoErr = http2ConfigureServer(srv, conf) } } 然后是调用如下代码：\n#h2_bundle.go ... // ConfigureServer adds HTTP/2 support to a net/http Server. // // The configuration conf may be nil. // // ConfigureServer must be called before s begins serving. func http2ConfigureServer(s *Server, conf *http2Server) error { ... }  HTTP1 流水线，一条连接一个并发；HTTP2 是每个连接一个并发，每处理一个请求又是一个并发。  延伸阅读  HTTP2 协议 多路复用  ","title":"第 9 期 2018-06-14 线下活动"},{"location":"http://bytemode.github.io/reading/8-2018-05-31-net-http-part2/","text":"  参与人数: 10 人\n Go 标准包阅读\nGo 版本：go 1.10.2\nnet/http  server.go  问题    func (s *Server) doKeepAlives() bool { return atomic.LoadInt32(\u0026amp;s.disableKeepAlives) == 0 \u0026amp;\u0026amp; !s.shuttingDown() } 为什么要用 atomic.LoadInt32(\u0026amp;s.disableKeepAlives) == 0 ？\n原子操作比用锁更节约一点性能。\n server.go#Shutdown 不保险\n panicChan := make(chan interface{}, 1)\n  panicChan := make(chan interface{}, 1) go func() { defer func() { if p := recover(); p != nil { panicChan \u0026lt;- p } }() h.handler.ServeHTTP(tw, r) close(done) }() select { case p := \u0026lt;-panicChan: panic(p) ... 外部处理就不能按照你的意愿去处理了，如果不拿出来，那么进程就挂掉了。\n // Deprecated: ErrWriteAfterFlush is no longer used. ErrWriteAfterFlush = errors.New(\u0026ldquo;unused\u0026rdquo;)\n Header() Header 注释引发的Trailer的思考？\n  观看视频   延伸阅读  HTTP Chunked Body/Trailer编码 example_ResponseWriter_trailers HTTP Header Trailer  ","title":"第 8 期 2018-05-31 线下活动 - Go 标准包阅读"},{"location":"http://bytemode.github.io/reading/7-2018-05-24-net-http-part1/","text":"  参与人数: 10 人\n Go 标准包阅读\nGo 版本：go 1.10.1\nnet/http  server.go  问题  Next Protocol Negotiation = NPN Expect 100 Continue support   见参考资料\n  header提到了：Expect和host 判断了 header里面的HOST，但是后面又删除，为什么？  server.go#L980\ndelete(req.Header, \u0026#34;Host\u0026#34;)  判断是否支持 HTTP2 （isH2Upgrade）  // isH2Upgrade reports whether r represents the http2 \u0026#34;client preface\u0026#34; // magic string. func (r *Request) isH2Upgrade() bool { return r.Method == \u0026#34;PRI\u0026#34; \u0026amp;\u0026amp; len(r.Header) == 0 \u0026amp;\u0026amp; r.URL.Path == \u0026#34;*\u0026#34; \u0026amp;\u0026amp; r.Proto == \u0026#34;HTTP/2.0\u0026#34; }调用：ProtoAtLeast(1, 1) ... // ProtoAtLeast reports whether the HTTP protocol used // in the request is at least major.minor. func (r *Request) ProtoAtLeast(major, minor int) bool { return r.ProtoMajor \u0026gt; major || r.ProtoMajor == major \u0026amp;\u0026amp; r.ProtoMinor \u0026gt;= minor } 会议讨论 20:07:45 From 永京 李 : ok 20:07:46 From 斯 艾 : 可以 20:07:50 From joe sean : ok 20:07:51 From 洪范 郝 : 可以 20:07:54 From 力宁 关 : 可以 20:08:01 From 洪范 郝 : 可以 20:08:05 From 力宁 关 : ok 20:08:09 From joe sean : 有杂音 20:08:46 From 斯 艾 : 有声音 20:08:51 From joe sean : 有的 20:08:54 From Jayden Yang : 有 20:08:59 From 永京 李 : you 20:09:17 From Jayden Yang : 回声 20:09:17 From 洪范 郝 : 噪音太大 20:10:28 From caigaoxing : 2343 20:12:43 From 洪范 郝 : 屏幕卡了? 20:12:49 From joe sean : 1 20:12:53 From Jayden Yang : 1 20:13:57 From 迪 麦 : 屏幕是卡主了 20:14:26 From joe sean : 能看到鼠标动，看不到屏幕动 20:16:18 From caigaoxing : ok 20:17:25 From caigaoxing : 是不是不动了 20:17:45 From 和宽 熊 : 动了 20:17:47 From joe sean : activeConn是连接池吧 20:19:03 From joe sean : 又卡了 20:19:43 From 斯 艾 : 屏幕不动了 20:20:38 From kas li : 不行哦， 卡屏，只有鼠标能显示 20:20:43 From caigaoxing : 1 20:20:44 From caigaoxing : 1 20:20:44 From caigaoxing : 1 20:20:44 From caigaoxing : 1 20:20:44 From caigaoxing : 1 20:20:45 From caigaoxing : 1 20:20:45 From caigaoxing : 1 20:20:45 From caigaoxing : 1 20:20:45 From caigaoxing : 1 20:20:46 From caigaoxing : 1 20:20:46 From caigaoxing : 1 20:20:46 From caigaoxing : 1 20:20:46 From caigaoxing : 1 20:20:46 From caigaoxing : 1 20:20:46 From caigaoxing : 1 20:20:47 From caigaoxing : 1 20:20:48 From caigaoxing : 1 20:20:51 From caigaoxing : 卡了 20:20:55 From caigaoxing : 卡了 20:20:58 From joe sean : 1 20:21:04 From 建雷 张 : hi 20:21:07 From kas li : 卡屏，只有鼠标能显示 20:21:08 From caigaoxing : 不动了屏幕 20:21:09 From 叶 思杰 : 只能看到屏幕 20:21:14 From 叶 思杰 : 只能看到鼠标 20:21:19 From joe sean : ok 20:21:28 From brile ho : ok 20:21:31 From 叶 思杰 : ok 20:22:18 From kas li : 多余的视频关了，减少带宽使用 20:25:52 From caigaoxing : ok 20:25:56 From joe sean : 可以 20:26:01 From 夜 暗 : 先整体，再细节？ 20:26:02 From 龙 周 : ok 20:26:04 From kas li : 跳进去有思路，也是不错的 20:26:31 From yi zhang : 听到声音了 20:29:20 From 洪范 郝 : setupHTTP2_Serve 这命名不规范呀 20:30:09 From DW : 跟踪 listener 主要是做什么的？ 20:30:59 From ksir : 用goland不是很爽？ 20:31:09 From yi zhang : 用goland啊 20:31:12 From Jayden Yang : goland呢 20:31:19 From Jayden Yang : vscode呢 20:31:27 From DW : sublime 跳转也很好用 20:32:05 From 建雷 张 : emacs 20:32:53 From mai yang : 现在直播正常了吧。 20:33:07 From DW : 临时错误 20:36:18 From DW : 我还以为是动然规划算法 。。。 20:36:43 From 永京 李 : backoff 算法设置重试间隔 20:37:40 From DW : 协程数量有没有限制的？ 20:37:54 From 洪范 郝 : 可以 20:39:08 From Jayden Yang : 直接深入吧 20:39:12 From yi zhang : srv.trackListener(l, true) defer srv.trackListener(l, false) 20:39:21 From yi zhang : 这两个函数是在干嘛啊？ 20:39:46 From DW : 每连接一个连接，就 go 一个，会不会出现资源耗尽？ 20:42:38 From yi zhang : srv.trackListener(l, true) defer srv.trackListener(l, false) 这两个函数是在干嘛啊？ 20:43:29 From yi zhang : 嗯 好 20:43:37 From yi zhang : 谢谢 20:44:14 From 洪范 郝 : 代码为啥不一样呢 20:44:41 From 大 猫 : @DW 我感觉创建上百万个协程没事，而且一个连接处理完了，资源就会回收 20:47:02 From mai yang : go1.10 20:47:05 From DW : 也就是说还没有一个安全机制进行控制是吧 @大猫 20:49:54 From 大 猫 : 有没有机制我也不知道，如果系统实在没法继续处理的话，应该表现的会卡，然后超时 20:50:45 From DW : 单机应该支持不了那么多的 20:51:12 From jinleileiking : 提问的人说的话听不清楚 20:51:19 From DW : 这里的 context 主要作用是什么？ 20:52:18 From yi zhang : 控制其他goroutine的 取消、停止 等一些操作吧 20:53:05 From DW : 嗯，对应该是与其他 goroutine 交互的 20:54:08 From yi zhang : 哈哈 真的应该早点用用goland，没法跟踪函数，看interface的实现，简直就没法看代码啊 20:54:44 From jinleileiking : vim-go 跳转无压力 20:56:54 From DW : vs 无压力 20:58:51 From yi zhang : infinite 20:58:58 From yi zhang : 时间吧 20:59:01 From jinleileiking : { cr.remain = maxInt64 } 20:59:03 From yi zhang : 无穷 21:01:12 From yi zhang : 950 21:01:17 From yi zhang : :950 21:04:22 From DW : 主次版本 21:04:29 From Jayden Yang : \u0026amp;\u0026amp; 优先级高么 21:04:46 From cym : major.minor 21:04:47 From DW : || 最高 21:08:36 From yi zhang : // ValidHostHeader reports whether h is a valid host header. func ValidHostHeader(h string) bool { // The latest spec is actually this: // // http://tools.ietf.org/html/rfc7230#section-5.4 // Host = uri-host [ \u0026ldquo;:\u0026rdquo; port ] // // Where uri-host is: // http://tools.ietf.org/html/rfc3986#section-3.2.2 // // But we\u0026rsquo;re going to be much more lenient for now and just // search for any byte that\u0026rsquo;s not a valid byte in any of those // expressions. for i := 0; i \u0026lt; len(h); i++ { if !validHostByte[h[i]] { return false } } return true } 21:09:43 From 建雷 张 : godef: no declaration found for httplex.ValidHostHeader 21:09:57 From Jayden Yang : httplex.go 21:10:29 From jinleileiking : - var validHostByte = [256]bool{ | \u0026lsquo;0\u0026rsquo;: true, \u0026lsquo;1\u0026rsquo;: true, \u0026lsquo;2\u0026rsquo;: true, \u0026lsquo;3\u0026rsquo;: true, \u0026lsquo;4\u0026rsquo;: true, \u0026lsquo;5\u0026rsquo;: true, \u0026lsquo;6\u0026rsquo;: true, \u0026lsquo;7\u0026rsquo;: true, | \u0026lsquo;8\u0026rsquo;: true, \u0026lsquo;9\u0026rsquo;: true, | | \u0026lsquo;a\u0026rsquo;: true, \u0026lsquo;b\u0026rsquo;: true, \u0026lsquo;c\u0026rsquo;: true, \u0026rsquo;d\u0026rsquo;: true, \u0026lsquo;e\u0026rsquo;: true, \u0026lsquo;f\u0026rsquo;: true, \u0026lsquo;g\u0026rsquo;: true, \u0026lsquo;h\u0026rsquo;: true, 21:10:55 From Jayden Yang : /usr/local/go/src/vendor/golang_org/x/net/lex/httplex/httplex.go 21:12:06 From jinleileiking : [256]bool 下标是 ‘0’ 21:13:41 From 协 崔 : if deleteHostHeader { delete(req.Header, \u0026ldquo;Host\u0026rdquo;) }卧槽，我看到的是这样的 21:14:40 From joe sean : 1 21:15:17 From mai yang : go1.10.1 21:15:20 From Jayden Yang : deleteHostHeader 这个又是啥 21:15:22 From mai yang : 我们基于这个版本的。 21:16:03 From Jayden Yang : // whether Close should stop early 21:19:15 From 协 崔 : 有个 叫chunked的编码 21:28:40 From 马嘉 : 再来把 21:29:25 From 建雷 张 : \u0026hellip; 21:29:28 From mai yang to Henry Lee (Privately) : 刚刚网络问题中断了。现在继续。 21:29:38 From mai yang : 刚刚网络问题中断了。现在继续。 21:29:45 From 大 猫 : 屏幕没共享 21:30:54 From 马嘉 : ok 21:31:01 From 建雷 张 : ok 21:32:19 From Jayden Yang : 你们只能开一个 21:32:24 From Jayden Yang : 现场只开一个 21:32:34 From Jayden Yang : 音中音了 21:38:52 From DW : 什么样的客户端会使用 100-continue 协议呢？ 21:39:21 From Core Code : 这个是询问服务端是否支持大的包吧 21:39:48 From DW : 浏览器是不是自动实现了这种协议 21:52:15 From 洪范 郝 : // Buffered returns the number of bytes that can be read from the current buffer. func (b *Reader) Buffered() int { return b.w - b.r } 21:57:59 From Jayden Yang : closeNotifyCh is the channel returned by CloseNotify. 21:59:06 From Jayden Yang : 发送关闭信号给所有的goroutune 21:59:41 From Jayden Yang : // closeNotifyCh是由CloseNotify返回的频道。 // TODO（bradfitz）：目前（对于Go 1.8）总是这样 //非零。 让这个懒洋洋地再创造一次，因为它曾经是？ 22:12:04 From Jayden Yang : 看不到屏幕 22:12:37 From jinleileiking : 看不到屏幕\n延伸阅读  https://github.com/golang/go/issues/22128 https://tools.ietf.org/html/draft-ietf-httpbis-p2-semantics-26#section-6.2.1 https://www.cnblogs.com/tekkaman/archive/2013/04/03/2997781.html https://benramsey.com/blog/2008/04/http-status-100-continue/ http://www.ituring.com.cn/article/130844  观看视频   ","title":"第 7 期 2018-05-24 线下活动 - Go 标准包阅读"},{"location":"http://bytemode.github.io/reading/6-2018-05-17-strings-part4/","text":"  参与人数: 12 人\n Go 标准包阅读\nGo 版本：go 1.10.1\nstrings  strings.go  问题清单 以下是我们在阅读过程中的一些问题，希望可以引起大家的关注，也欢迎大家提出自己的理解，最好可以给以文章总结。\n // Remove if golang.org/issue/6714 is fixed bp := copy(b, a[0]) return len(s) \u0026gt;= len(prefix) \u0026amp;\u0026amp; s[0:len(prefix)] == prefix 各种开发语言都有的短路机制；字符串底层也是可以用作切片的； 为什么要判断这个错误： if c == utf8.RuneError c -= \u0026lsquo;a\u0026rsquo; - \u0026lsquo;A\u0026rsquo; （小写转大写的算法） // Since we cannot return an error on overflow, // we should panic if the repeat will generate // an overflow. // See Issue golang.org/issue/16237 truth asciiSet （bitset 标记位，存在标记为1）  传一个字符串，把字符串包含的ascii，对应的256位，进行映射。\n Unicode 包很多都看不懂。\n func isSeparator(r rune) bool\n  延伸阅读    ","title":"第 6 期 2018-05-17 线下活动 - Go 标准包阅读"},{"location":"http://bytemode.github.io/reading/5-2018-05-10-strings-part3/","text":"  参与人数: 20 人\n Go 标准包阅读\nGo 版本：go 1.10.1\nstrings  strings.go（进度50%）  问题清单 以下是我们在阅读过程中的一些问题，希望可以引起大家的关注，也欢迎大家提出自己的理解，最好可以给以文章总结。\n重头戏：Rabin-Karp search\nRabin-Karp 算法的思想：\n 假设待匹配字符串的长度为M，目标字符串的长度为N（N\u0026gt;M）； 首先计算待匹配字符串的hash值，计算目标字符串前M个字符的hash值； 比较前面计算的两个hash值，比较次数N-M+1：  若hash值不相等，则继续计算目标字符串的下一个长度为M的字符子串的hash值 若hash值相同，则需要使用朴素算法再次判断是否为相同的字串    16777619 为什么是这个值？ RK, FNV 算法 16777619 = (2^24 + 403)) len 计算问题？是否是每次都会计算，直接拿值，不需要单独计算的；  len(string) 的获取 string 的长度问题：\n 涉及到 string 的结构问题。\n 在runtime/strings.go 中可以看到对应的 string 结构：\ntype stringStruct struct { str unsafe.Pointer len int } 可以得到在求 string 的长度的时候，实际上是直接获取值。\n在 slice 的结构体中\ntype slice struct { array unsafe.Pointer len int cap int } Len 方法跟 len 长度走。\ntype hmap struct { // Note: the format of the Hmap is encoded in ../../cmd/internal/gc/reflect.go and  // ../reflect/type.go. Don\u0026#39;t change this structure without also changing that code!  count int // # live cells == size of map. Must be first (used by len() builtin)  flags uint8 B uint8 // log_2 of # of buckets (can hold up to loadFactor * 2^B items)  noverflow uint16 // approximate number of overflow buckets; see incrnoverflow for details  hash0 uint32 // hash seed  buckets unsafe.Pointer // array of 2^B Buckets. may be nil if count==0.  oldbuckets unsafe.Pointer // previous bucket array of half the size, non-nil only when growing  nevacuate uintptr // progress counter for evacuation (buckets less than this have been evacuated)  extra *mapextra // optional fields } 在map的结构体重 有个 count 的统计 map 的内部数量。\n len 与 runtime 包里面的某些实现的有何区别？  func IndexByte(s string, c byte) int // ../runtime/asm_$GOARCH.s）\n strings.s  # strings.s\n// Copyright 2013 The Go Authors. All rights reserved. // Use of this source code is governed by a BSD-style // license that can be found in the LICENSE file. // This file is here just to make the go tool happy.  *.s 文件存在的原因是 Go 在编译的时候会启用 -compile 编译器 flag ，它要求所有的函数必须包含函数体，创建一个空的汇编语言文件绕开这个限制。\n go:linkname   控制谁可以调用它。\n Go 的隐藏功能\n//go:noescape //go:noinline //go:nosplit //go:linkname ... 其它 // +build //go:generate package xxx // import \u0026quot;xxx\u0026quot; //line  其中有一些 net_linux.go 或 asm_amd64.s，Go 语言的构建工具将只在对应的平台编译这些文件。 如果在包中加入 // +build linux darwin 表示该包只在 linux 和 mac 下被编译。 而 // +build ignore 是忽略该包。\n它跟 internal 有什么不同呢？\n 一个internal包只能被和internal目录有同一个父目录的包所导入。\n 举例说明：\ntime.Sleep()的实现函数在runtime包的time.go \u0026hellip;\n其他更多的使用，大家可以自行搜索 go:linkname\n更多相关知识，大家可点击：突破限制,访问其它Go package中的私有函数\n (i+16)/8 这个16，8是什么意思？怎么解读这个逻辑的呢？  // Switch to indexShortStr when IndexByte produces too many false positives. // Too many means more that 1 error per 8 characters. // Allow some errors in the beginning. if fails \u0026gt; (i+16)/8 { r := indexShortStr(s[i:], substr) if r \u0026gt;= 0 { return r + i } return -1 }  逻辑是什么意思呢？  // contains reports whether c is inside the set. func (as *asciiSet) contains(c byte) bool { return (as[c\u0026gt;\u0026gt;5] \u0026amp; (1 \u0026lt;\u0026lt; uint(c\u0026amp;31))) != 0 }  makeASCIISet  // ascii空格包括\\t,\\n,\\v,\\f,\\r, ` ` var asciiSpace = [256]uint8{\u0026#39;\\t\u0026#39;: 1, \u0026#39;\\n\u0026#39;: 1, \u0026#39;\\v\u0026#39;: 1, \u0026#39;\\f\u0026#39;: 1, \u0026#39;\\r\u0026#39;: 1, \u0026#39; \u0026#39;: 1} 延伸阅读  大家一定要看这一篇文章：Rabin-Karp 算法（字符串快速查找） primes-16777619 Fowler–Noll–Vo hash function FNV Hash FNV哈希算法【学习】 字符串查找算法（二） 突破限制,访问其它Go package中的私有函数 How to call private functions (bind to hidden symbols) in GoLang 《深入解析 Go 之基本类型-字符串》  ","title":"第 5 期 2018-05-10 线下活动 - Go 标准包阅读"},{"location":"http://bytemode.github.io/reading/4-2018-04-25-strings-part2/","text":"  参与人数: 15 人\n Go 标准包阅读\nGo 版本：go 1.10.1\nstrings  replace.go replace_test.go search.go search_test.go  问题清单 以下是我们在阅读过程中的一些问题，希望可以引起大家的关注，也欢迎大家提出自己的理解，最好可以给以文章总结。\n Boyer-Moore 算法  延伸阅读  Boyer-Moore_string_search_algorithmde Boyer-Moore字符串搜索算法 字符串匹配的Boyer-Moore算法 grep之字符串搜索算法Boyer-Moore由浅入深（比KMP快3-5倍）  ","title":"第 4 期 2018-04-25 线下活动"},{"location":"http://bytemode.github.io/reading/3-2018-04-18-strings-part1/","text":"  参与人数: 14 人\n Go 标准包阅读\nGo 版本：go 1.10.1\nstrings  builder.go builder_test.go compare.go compare_test.go example_test.go export_test.go reader_test.go reader.go  问题清单 以下是我们在阅读过程中的一些问题，希望可以引起大家的关注，也欢迎大家提出自己的理解，最好可以给以文章总结。\n defer runtime.GOMAXPROCS(runtime.GOMAXPROCS(1)) runtime.ReadMemStats(\u0026amp;m1) defer_lock.go  package main import ( \u0026#34;sync\u0026#34; ) func main() { var mu sync.Locker = new(I) defer LockUnlock(mu)() println(\u0026#34;doing\u0026#34;) } func LockUnlock(mu sync.Locker) (unlock func()) { mu.Lock() return mu.Unlock } type I struct{} func (i *I) Lock() { println(\u0026#34;lock\u0026#34;) } func (i *I) Unlock() { println(\u0026#34;unlock\u0026#34;) }  buf := make([]byte, len(b.buf), 2*cap(b.buf)+n) 为什么是2倍呢？ // NOTE(rsc): This function does NOT call the runtime cmpstring function, // because we do not want to provide any performance justification for // using strings.Compare. Basically no one should use strings.Compare. // As the comment above says, it is here only for symmetry with package bytes. // If performance is important, the compiler should be changed to recognize // the pattern so that all code doing three-way comparisons, not just code // using strings.Compare, can benefit.\n b.buf = append(b.buf, s\u0026hellip;) s是string，b.buf是[]byte\n int int64的问题？ 在32位机器上进行int64原子操作时的panic\n defer LockUnlock(mu),如果LockUnlock(mu)没有带()，则会丢失func函数的执行\n if r \u0026lt; utf8.RuneSelf\n if cap(b.buf)-l \u0026lt; utf8.UTFMax {\n Example\n xxx_test.go 其实是xxx包，但是又不想放到xxx包里面，因为它只是提供给_test.go包使用的函数。\n rune 码点的处理（reader.go prevRune int // index of previous rune; or \u0026lt; 0）\n off 与 offset 尴尬的问题\n whence where when ？wiki-whence\n // It is similar to bytes.NewBufferString but more efficient and read-only.\n Go 1.10 开始引入了 builder\n  go1.10.builder\n# https://golang.org/doc/go1.10#strings strings ¶ A new type Builder is a replacement for bytes.Buffer for the use case of accumulating text into a string result. The Builder's API is a restricted subset of bytes.Buffer's that allows it to safely avoid making a duplicate copy of the data during the String method.  延伸阅读  wiki-whence Go 延迟函数 defer 详解  ","title":"第 3 期 2018-04-18 线下活动"},{"location":"http://bytemode.github.io/reading/2-2018-04-11-teleport/","text":"  参与人数: 9 人\n微服务相关的开源项目，直接根据 Github 讲解，三个相关的项目链接如下:\n  teleport是socket框架 tp-micro是它的扩展，实现了微服务 ants是该微服务的网关、配置中心、代码生成器、部署工具之类的  语音实录  以下内容是分享活动的实录回顾。\n  参与人数: 9人 参与者的自我介绍 演示 xiaoneai/ants 分析 tp-micro 和 teleport 框架代码 答疑 确定线下分享形式（标准包和开源项目）  语音实录\n语音实录（文字版本 by 录音宝）\n","title":"第 2 期 2018-04-11 线下分享内容"},{"location":"http://bytemode.github.io/reading/1-2018-03-21-goutil/","text":"  参与人数: 3 人\n cannot take address of temporary variables 延伸阅读  https://stackoverflow.com/questions/10535743/address-of-a-temporary-in-go https://stackoverflow.com/questions/40926479/take-the-address-of-a-character-in-string https://golang.org/ref/spec#Address_operators  neochain teleport Teleport 是一个通用、高效、灵活的Socket框架。\n可用于 Peer-Peer 对等通信、RPC、长连接网关、微服务、推送服务，游戏服务等领域。\ngoutil 通用的 Go 开发工具包\n Calendar CoarseTime \u0026hellip;  ","title":"第 1 期 2018-03-21 线下分享内容"},{"location":"http://bytemode.github.io/categories/","text":"","title":"Categories"},{"location":"http://bytemode.github.io/tags/","text":"","title":"Tags"}]