<?xml version="1.0" encoding="utf-8" standalone="yes"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Go 源码阅读 on Go Learn</title>
    <link>http://bytemode.github.io/reading/</link>
    <description>Recent content in Go 源码阅读 on Go Learn</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 15 Nov 2018 12:32:37 +0800</lastBuildDate>
    
	<atom:link href="http://bytemode.github.io/reading/index.xml" rel="self" type="application/rss+xml" />
    
    
    <item>
      <title>第 67 期 Go database/sql 数据库连接池分析</title>
      <link>http://bytemode.github.io/reading/67-2019-11-14-sql-pool-reading/</link>
      <pubDate>Thu, 14 Nov 2019 21:00:00 +0800</pubDate>
      
      <guid>http://bytemode.github.io/reading/67-2019-11-14-sql-pool-reading/</guid>
      <description> Go 夜读第 67 期 Go database/sql 数据库连接池分析 本期 Go 夜读是由 POP 后端团队的邹文通给大家带来的 Go 标准包 database/sql 数据库连接池源码剖析。
大纲  sql 连接池简介 连接池的工作原理 sql 包连接池源码分析 连接池使用 tips  Slides  https://docs.google.com/presentation/d/10kGjeHGbB0h0Cz8f58reXOyCdyWSOSKrr2160IFNla4/edit?usp=sharing  回看视频  https://www.bilibili.com/video/av75690189/ https://youtu.be/JKJ8ehtiqUM  参考资料  Go组件学习——database/sql数据库连接池你用对了吗 Go组件学习——手写连接池并没有那么简单 Chapter 8 Connection Pooling with Connector/J 彻底弄懂mysql（二）&amp;ndash;连接方式  观看视频   </description>
    </item>
    
    <item>
      <title>第 66 期 Paper Reading CSP 理解顺序进程间通信</title>
      <link>http://bytemode.github.io/reading/66-2019-11-07-paper-reading-csp/</link>
      <pubDate>Thu, 07 Nov 2019 21:00:00 +0800</pubDate>
      
      <guid>http://bytemode.github.io/reading/66-2019-11-07-paper-reading-csp/</guid>
      <description>Go 夜读第 66 期 Paper Reading CSP 理解顺序进程间通信 本期 Go 夜读是由 Go 夜读 SIG 核心小组成员欧长坤给大家带来的经典论文 CSP 的 Paper Reading。
CSP 是什么？ 我们常常在讨论中提及 CSP，但鲜有人能真正说清楚 CSP 的演进历史，及其最核心的基本思想。我们已经对 Go 提供的并发原语足够熟悉了，是时候深入理解其背后的基础理论 —— 顺序进程间通信（Communicating Sequential Processes, CSP）了。本次分享我们针对 [Hoare 1978] 探讨 CSP 理论的原始设计（CSP 1978），主要围绕以下几个问题展开：
Tony Hoare 提出 CSP 的时代背景是什么？ - CSP 1978 理论到底有哪些值得我们研究的地方？ - CSP 1978 理论是否真的就是我们目前熟知的基于通道的同步方式？ - CSP 1978 理论的早期设计存在什么样的缺陷？
大纲  CSP 1978 的诞生背景 CSP 1978 的主要内容及其结论 CSP 1978 理论中存在的设计缺陷 讨论与反思  分享 Slides  https://docs.</description>
    </item>
    
    <item>
      <title>第 65 期 Go 原生网络模型 vs 异步 Reactor 模型</title>
      <link>http://bytemode.github.io/reading/65-2019-10-31-go-net/</link>
      <pubDate>Thu, 31 Oct 2019 21:00:00 +0800</pubDate>
      
      <guid>http://bytemode.github.io/reading/65-2019-10-31-go-net/</guid>
      <description>Go 夜读第 65 期 Go 原生网络模型 vs 异步 Reactor 模型 本期 Go 夜读是由 Go 夜读 SIG 核心小组邀请到潘建锋给大家分享 Go 原生网络模型 vs 异步 Reactor 模型，以下是本次分享的部分内容和 QA 。 &amp;gt;潘建锋，曾任职腾讯、现亚马逊在职。Go 语言业余爱好者，开源库 gnet 和 ants 作者。
引子 我们都知道 Golang 基于 goroutine 构建了一个简洁而优秀的原生网络模型，让开发者能够用同步的模式去编写异步的逻辑：goroutine-per-connection 模式，极大地降低了开发者编写网络应用时的心智负担，而且借助于 Go Scheduler 对 goroutines 的高效调度，这个原生网络模型足以应对绝大部分的应用场景。
然而，在工程性上能做到如此高的普适和兼容，给开发者提供如此简单易用的接口，其背后必然是基于非常复杂的封装，做了很多取舍，放弃了一些『极致』的概念和设计。事实上 Golang 的 netpoll 底层就是基于 epoll/kqueue/iocp 这些系统调用来做封装的，最终暴露出 goroutine-per-connection 这样的网络编程模式给开发者。
在绝大部分应用场景下，我推荐大家还是遵循 Golang 的 best practices，以这种模式来构建自己的网络应用，然而，在某些极度需要提高性能、节省资源以及技术栈必须是原生 Go （不考虑 C/C++ 写中间层供 Go 调用）的场景下，我们可以考虑自己构建 Reactor 网络模型。那么，Reactor 模型相对原生模型有哪些优势和弊端呢？我开发了的一个基于事件驱动机制的实验性质的异步网络框架：gnet，其在性能和资源占用上都远超 Go 原生 net 包（少数特定的应用场景），通过解析这个框架和 Go 原生网络模型，我们来一一分析～～</description>
    </item>
    
    <item>
      <title>第 64 期深入浅出 Golang Runtime</title>
      <link>http://bytemode.github.io/reading/64-2019-10-24-go-runtime/</link>
      <pubDate>Thu, 24 Oct 2019 21:00:00 +0800</pubDate>
      
      <guid>http://bytemode.github.io/reading/64-2019-10-24-go-runtime/</guid>
      <description>Go 夜读第 64 期深入浅出 Golang Runtime 内容简介 本次分享将会对 go runtime 的调度，内存分配，gc 做一些细节上的讲解，同时也需要参与者对 runtime 有一些初步了解。
内容大纲  Golang Runtime 是什么，其发展历程； 调度的实质和关键数据结构，函数； 内存分配中 mspan, mheap, mcentral, mcache 等数据结构 Golang GC 发展，Golang 三色标记实现的一些细节，元信息，写屏障，1.5 与 1.12 GC 的区别； 一点优化思路与问题排查思路； 总结及 question； 平时我看 runtime 代码的一些方式；  分享嘉宾 郝以奋，yifhao, 腾讯 NOW 直播后台开发，负责 NOW 直播 CPP+JAVA 双栈 -&amp;gt; Golang 转型：框架协同建设，业务功能定制，Go Mod 引入，服务模板，RPC 协议 Go Mod 化，服务模板，Golang 培训，文档等。
目前 NOW 直播后台有 300 多个 Go 服务。
分享信息 时间：2019-10-17 21:00:00 ~ 23:10:00, UTC+8 分享 Slides：https://github.</description>
    </item>
    
    <item>
      <title>第 63 期 Go 编码风格阅读与讨论</title>
      <link>http://bytemode.github.io/reading/63-2019-10-17-go-style-and-go-advices/</link>
      <pubDate>Thu, 17 Oct 2019 21:00:00 +0800</pubDate>
      
      <guid>http://bytemode.github.io/reading/63-2019-10-17-go-style-and-go-advices/</guid>
      <description>Go 夜读第 63 期 Go 编码风格阅读与讨论 内容简介 本期主要是针对近期 uber-go/guide style 和 go-advices 的解读以及开发者讨论。
内容大纲  Go CodeReview Comments Uber-go/style Go-advices  分享地址 2019-10-17 21:00:00 ~ 22:10:00, UTC+8
https://zoom.us/j/6923842137
分享 Slides https://docs.google.com/presentation/d/1MlzZJBK0Zq0VzJVC_AqSWmmlS4Of-8xY6NGZmfhKQXI/edit?usp=sharing
进一步阅读的材料  Go CodeReviewComments uber-go/guide style go-advices  Go CodeReviewComments 翻译  Go Code Review Comments 译文（截止 2018 年 7 月 27 日）  Go 官方的建议已经涉及到非常方面：
 Gofmt Comment Sentences Contexts Copying Crypto Rand Declaring Empty Slices Doc Comments Don&amp;rsquo;t Panic Error Strings Examples Goroutine Lifetimes Handle Errors Imports Import Dot In-Band Errors Indent Error Flow Initialisms Interfaces Line Length Mixed Caps Named Result Parameters Naked Returns Package Comments Package Names Pass Values Receiver Names Receiver Type Synchronous Functions Useful Test Failures Variable Names  gofmt 不管你是用什么开发工具，都推荐一定要配置 goimports。</description>
    </item>
    
    <item>
      <title>第 62 期 Go-Micro 微服务框架 Part 1</title>
      <link>http://bytemode.github.io/reading/62-2019-10-10-go-micro-part1/</link>
      <pubDate>Thu, 10 Oct 2019 21:00:00 +0800</pubDate>
      
      <guid>http://bytemode.github.io/reading/62-2019-10-10-go-micro-part1/</guid>
      <description>Go 夜读第 62 期 Go-Micro 微服务框架 Part 1 内容简介 介绍Go-Micro的设计及其重要组件
内容大纲  什么是 Micro Micro 风格服务架构 Go-Micro 框架的设计 Go-Micro 主要的组件 Go-Micro 的插件化  分享地址 2019-10-10 21:00 ~ 22:00, UTC+8
https://zoom.us/j/6923842137
进一步阅读的材料  Micro 项目 Micro 文档 示例项目 PPT  请点击：https://github.com/developer-learning/reading-go/issues/457
Q&amp;amp;A 总结  micro 是Restful吗？  答：go-micro并不是一个web框架，不过go-micro中有web模块可以提供restful风格服务。
 srv里面是包含client和server吗？  答：每一个服务都会有client和server，服务要能调用其它服务就需要一个client，能接收请求就需要server。
 为什么异构service互相调用一定要经过proxy，rpc不应该是编码和transport约定好本身就支持异构调用吗？  答：micro proxy并不支持互调，它提供一个go-micro特性的代理，其它非go-micro风格的服务通过这个代理加入go-micro体系，便可以通过proxy被其它服务调用，可以是http、grpc等。
我会在未来几天增加一篇专门介绍micro的文档在这里：micro proxy
 micro与k8s  答：这是一个常见的问题，micro会常与k8s、istio比较或联系，这是不公平的也是不合理的。主要在这么几个方面：
a) micro与k8s同时起步，或者说micro更早些，k8s的产生是基于容器技术的兴起，而容器需要管理与编排。K8s确实给大型服务集群提供了极好的运维平台，但是它在一定适度上并不是面向开发人员的工具，更多是面向运维人员的。
b) 基于a，Micro是面向开发人员的微服务框架，如果人们用了K8s，那应该就不要用micro。
c) 绝大部分开发者可以试问内心的需求：自己当下的服务运行需求，真的需要K8s吗？说句傲娇的话，如果不能看到micro的价值，那请不要使用micro，在K8s中使用micro，就像皇宫的大内总管，少了件最重要的东西。
 为啥要 consul 换成 etcd  答：从4年的结合Consul经验来说，它工作得比较正常但并不尽如人意，它有太多功能我们用不到。consul更多是面向Hashicorp体系的服务，而Etcd则更纯粹是服务注册组件，是的，我们需要更纯粹的中间件。更多可以参考一篇不太细致的博文：deprecating-consul</description>
    </item>
    
    <item>
      <title>第 60 期 IPFS 星际文件系统</title>
      <link>http://bytemode.github.io/reading/60-2019-09-19-ipfs-guide/</link>
      <pubDate>Thu, 19 Sep 2019 21:05:00 +0800</pubDate>
      
      <guid>http://bytemode.github.io/reading/60-2019-09-19-ipfs-guide/</guid>
      <description>Go 夜读第 60 期 IPFS 星际文件系统 背景介绍 传统的 HTTP 都是通过资源定位符来定位，在服务器关闭后，有些数据可能会永远丢失，而且如果某客户离服务器比较远，则可能延时较高。IPFS 提出使用基于内容寻址，只要拥有 hash 且网络上有人存储此数据，即可获得数据，同时自带 CDN 效果（热数据会自动分散）。
内容简介 主要介绍一下 ipfs 的基本思想与使用，并分析源码结构以及粗略介绍相关兄弟项目（如 multiformats,filecoin 等)
内容大纲  IPFS 的底层技术原理。 IPFS 源码概述。 超越 IPFS - 区块链存储简述。 Q&amp;amp;A。  分享地址 2019-09-19, 21:00 ~ 22:10, UTC+8
https://zoom.us/j/6923842137
进一步阅读的材料  IPFS paper 源码 PPT 预习资料  请点击：https://github.com/developer-learning/reading-go/issues/460
Q&amp;amp;A 总结  IPFS 是如何组网的？ 答：IPFS 的底层网络库是 Libp2p，Libp2p 的路由算法是 S-KadDHT（分布式哈希表），只要能连接到网络中的几个节点，通过节点发现与交换，很容易就能进入到网络里，所以需要设置 bootstrap 节点作为连接种子。对于个人或公司想用 IPFS 组网，可以用 swarm.key 组建一个私网（需要指定一bootstrap），即可实现内部的 IPFS 网络。
 IPFS 如何实现模糊搜索？ 答：首先 IPFS 的 DAG 节点里面都是有一个 name 项，此外还有一些其他的信息可以解析，这样的话可以爬取这些元数据信息，用一些搜索引擎工具即可模糊搜索，开源实现：https://github.</description>
    </item>
    
    <item>
      <title>第 59 期 Real-world Go Concurrency Bugs</title>
      <link>http://bytemode.github.io/reading/59-2019-09-12-real-world-go-concurrency-bugs-in-paper-reading/</link>
      <pubDate>Thu, 12 Sep 2019 21:00:00 +0800</pubDate>
      
      <guid>http://bytemode.github.io/reading/59-2019-09-12-real-world-go-concurrency-bugs-in-paper-reading/</guid>
      <description>Go 夜读第 59 期 Real-world Go Concurrency Bugs 内容简介 Go 语言鼓励其用户多使用基于消息传递的同步原语 channel，但也不排斥其用户使用基于内存共享的同步原语，提供了诸如 sync.Mutex 等互斥原语。在过去十年的时间里，Go 的实践者不断思考着这些问题：哪种同步原语更加优秀？究竟什么场景下应该使用何种同步原语？哪类同步原语能够更好的保证数据操纵的正确性？哪类同步原语对程序员的心智负担较大？何种同步原语更容易产生程序 Bug？channel 是一种反模式吗？什么类型的 Bug 能够更好的被 Bug 检测器发现？……
[Tu et al., 2019] 调研了包括 Docker, Kubernetes, gRPC 等六款主流大型 Go 程序在演进过程中出现的 171 个与同步原语相关的 Bug，并给出了一些有趣的见解。本次分享将讨论 [Tu et al. 2019] 的研究论文。
内容大纲  Go 常见的并发模式与论文的研究背景 论文的研究方法 Go 并发 Bug 的分类及部分主要结论  阻塞式 Bug 非阻塞式 Bug  Go 运行时死锁、数据竞争检测器对 Bug 的检测能力与算法原理（如果时间允许） 论文的结论、争议与我们的反思  分享地址 2019-09-12, 21:00 ~ 22:10, UTC+8
https://zoom.us/j/6923842137
进一步阅读的材料  [Ou, 2019a] Real-world Go Concurrency Bugs PPT  本次分享的 PPT: 这里  [Pike, 2012] Go Concurrency Patterns  Rob Pike 关于 「Go 并发模式」的 PPT  [Gerrand, 2013] Advanced Go Concurrency Patterns  Sameer Ajmani 关于 「Go 并发模式进阶」的 PPT  [Tu et al.</description>
    </item>
    
    <item>
      <title>第 58 期 What&#39;s new in Go 1.13？</title>
      <link>http://bytemode.github.io/reading/58-2019-09-05-whats-new-in-go1.13/</link>
      <pubDate>Thu, 05 Sep 2019 21:05:00 +0800</pubDate>
      
      <guid>http://bytemode.github.io/reading/58-2019-09-05-whats-new-in-go1.13/</guid>
      <description> Go 夜读第 58 期 What&amp;rsquo;s new in Go 1.13？ 内容简介
主要介绍了刚刚发布的 Go 1.13 Release 的内容。
内容大纲 - Go modules - Toolchain - Runtime - CoreLibrary Improve Performance - Q&amp;amp;A
分享地址 2019-09-05, 21:00 ~ 22:10, UTC+8
https://zoom.us/j/6923842137
进一步阅读的材料  https://golang.org/doc/go1.13 improve defer perfermance 30% goproxy.cn - 为中国 Go 语言开发者量身打造的模块代理  更多见：https://github.com/developer-learning/reading-go/issues/465
观看视频   </description>
    </item>
    
    <item>
      <title>第 57 期 sync/semaphore 源码浅析</title>
      <link>http://bytemode.github.io/reading/57-2019-08-29-sync-semaphore/</link>
      <pubDate>Thu, 29 Aug 2019 21:00:00 +0800</pubDate>
      
      <guid>http://bytemode.github.io/reading/57-2019-08-29-sync-semaphore/</guid>
      <description> Go 夜读第 57 期 sync/semaphore 源码浅析 内容简介
主要分析 golang.org/x/sync/semaphore 相关代码和 semaphore 部分使用场景。
内容大纲 - semaphore 定义 - 源码分析 - Q&amp;amp;A
分享地址 2019.08.29, 21:00 ~ 21:40, UTC+8
https://zoom.us/j/6923842137
进一步阅读的材料  semaphore 定义 源码 分享 PPT  补充资料  同步原语 结合 errgroup 使用 关于是否应该支持 resize 的讨论 semaphore 实现的 taskpool  更多见：https://github.com/developer-learning/reading-go/issues/456
观看视频   </description>
    </item>
    
    <item>
      <title>第 56 期 channel &amp; select 源码分析</title>
      <link>http://bytemode.github.io/reading/56-2019-08-22-channel-select-in-go/</link>
      <pubDate>Thu, 22 Aug 2019 21:00:00 +0800</pubDate>
      
      <guid>http://bytemode.github.io/reading/56-2019-08-22-channel-select-in-go/</guid>
      <description>Go 夜读第 56 期 channel &amp;amp; select 源码分析 内容简介
Go 语言除了提供传统的互斥量、同步组等同步原语之外，还受 CSP 理论的影响，提供了 channel 这一强有力的同步原语。本次分享将讨论 channel 及其相关的 select 语句的源码，并简要讨论 Go 语言同步原语中的性能差异与反思。
内容大纲 - 同步原语概述 - channel/select 回顾 - channel 的结构设计 - channel 的初始化行为 - channel 的发送与接收过程及其性能优化 - channel 的回收 - select 的本质及其相关编译器优化
分享地址 2019.08.22, 20:30 ~ 21:30, UTC+8
https://zoom.us/j/6923842137
进一步阅读的材料 [Ou, 2019] channel &amp;amp; select 源码分析 分享内容的 PPT [Ou, 2018] Go 源码研究 分享者写的一本 Go 源码分析 [Mullender and Cox, 2008] S.</description>
    </item>
    
    <item>
      <title>第 55 期 Go&amp;WebAssembly 简介</title>
      <link>http://bytemode.github.io/reading/55-2019-08-15-go-webassembly-guide/</link>
      <pubDate>Thu, 15 Aug 2019 21:00:00 +0800</pubDate>
      
      <guid>http://bytemode.github.io/reading/55-2019-08-15-go-webassembly-guide/</guid>
      <description>Go 夜读第 55 期 Go&amp;amp;WebAssembly 简介 WebAssembly 简介 WebAssembly 是一种新兴的网页虚拟机标准，它的设计目标包括：高可移植性、高安全性、高效率（包括载入效率和运行效率）、尽可能小的程序体积。
根据 Ending 定律：⼀切可被编译为 WebAssembly 的，终将被编译为 WebAssembly。
本次分享 Go&amp;amp;WebAssembly 相关的用法。
分享时间 2019-08-15 21:00:00
分享平台 zoom 在线直播 - https://zoom.us/j/6923842137
更多讨论 FelixSeptem：补充一下 go 官方给的 wiki https://github.com/golang/go/wiki/WebAssembly 以及 WebAssembly 官网 https://webassembly.org/ 个人比较倾向于对于 https://github.com/gopherjs/gopherjs 来比较理解，相对于 go-&amp;gt;js (包括 react 等等) 的方案，WebAssembly 带来的异同是什么？
chai2010 ：@FelixSeptem wasm 和 gopherjs 最大的差异：wasm 是官方支持，同时 wasm 是国际标准是其它语言认可的中间格式。
以前虽然很多工具输出 js，那是因为没有 wasm 可以选择。 现在有了 wasm，大家肯定只支持 wasm 而逐渐弱化 js 的支持。 毕竟 wasm 虚拟机实现比 v8 简单多了，性能又可以秒杀 js。</description>
    </item>
    
    <item>
      <title>第 54 期 Go 夜读之 TiDB SQL 兼容性测试工具简介</title>
      <link>http://bytemode.github.io/reading/54-2019-08-14-tidb-sql-tools/</link>
      <pubDate>Wed, 14 Aug 2019 21:00:00 +0800</pubDate>
      
      <guid>http://bytemode.github.io/reading/54-2019-08-14-tidb-sql-tools/</guid>
      <description> Go 夜读第 54 期 TiDB SQL 兼容性测试工具简介 本次分享包含两方面内容：
通过 MySQL yacc 文件生成 SQL Cases，并用于 TiDB 的兼容性测试的原理讲解。 TiDB Parser 兼容性社区活动介绍，手把手的演示如何参与本次社区活动。
(彩蛋：Parser Working Group 成立了，有兴趣的小伙伴可以看视频然后扫描加入。)
分享时间 2019-08-14 21:00:00
分享平台 zoom 在线直播 - https://zoom.us/j/6923842137
参考资料  三十分钟成为 Contributor | 提升 TiDB Parser 对 MySQL 8.0 语法的兼容性  观看视频   </description>
    </item>
    
    <item>
      <title>第 53 期 Go 夜读之 build in func delete from map</title>
      <link>http://bytemode.github.io/reading/53-2019-08-01-build-in-delete-from-map-in-go/</link>
      <pubDate>Thu, 01 Aug 2019 21:10:00 +0800</pubDate>
      
      <guid>http://bytemode.github.io/reading/53-2019-08-01-build-in-delete-from-map-in-go/</guid>
      <description> Go 夜读第 53 期 delete from map in go 突然有一个需求要删除 map 中的一些过滤数据。 &amp;gt;由此查阅了一些资料，然后促成此次分享。
PPT： build-in func delete from map in go.pptx
分享时间 2019-08-01 21:00:00
分享平台 zoom 在线直播 - https://zoom.us/j/6923842137
参考资料  https://stackoverflow.com/questions/1736014/delete-mapkey-in-go https://blog.cyeam.com/json/2017/11/02/go-map-delete https://blog.golang.org/go-maps-in-action https://gobyexample.com/maps https://stackoverflow.com/questions/23229975/is-it-safe-to-remove-selected-keys-from-map-within-a-range-loop https://www.cnblogs.com/qcrao-2018/p/10903807.html https://appdividend.com/2019/05/12/golang-maps-tutorial-with-examples-maps-in-go-explained/ https://www.jianshu.com/p/92e9efec8688 https://www.reddit.com/r/golang/comments/5tfx7i/why_delete_doesnt_return_a_bool/ https://www.liwenzhou.com/posts/Go/08_map/ https://github.com/EDDYCJY/blog/tree/master/map  观看视频   </description>
    </item>
    
    <item>
      <title>第 52 期 Go 夜读之 httprouter 简介</title>
      <link>http://bytemode.github.io/reading/52-2019-07-25-httprouter-guide/</link>
      <pubDate>Thu, 25 Jul 2019 21:10:00 +0800</pubDate>
      
      <guid>http://bytemode.github.io/reading/52-2019-07-25-httprouter-guide/</guid>
      <description> httprouter 简介 详细内容，可以查看 https://cch123.github.io/httprouter/
观看视频   </description>
    </item>
    
    <item>
      <title>第 51 期 Go 夜读之 sync/errgroup 源码阅读</title>
      <link>http://bytemode.github.io/reading/51-2019-07-18-sync-errgroup/</link>
      <pubDate>Thu, 18 Jul 2019 21:10:00 +0800</pubDate>
      
      <guid>http://bytemode.github.io/reading/51-2019-07-18-sync-errgroup/</guid>
      <description> golang.org/x/sync/errgroup errgroup 唯一的坑是for循环里千万别忘了 i, x := i, x，以前用 waitgroup 的时候都是 go func 手动给闭包传参解决这个问题的，errgroup 的.Go没法这么干，犯了好几次错才改过来&amp;rdquo;
观看视频   </description>
    </item>
    
    <item>
      <title>第 50 期 Go 夜读之 GoLand Tips &amp; Tricks</title>
      <link>http://bytemode.github.io/reading/50-2019-06-27-goland-practrice/</link>
      <pubDate>Thu, 27 Jun 2019 21:10:00 +0800</pubDate>
      
      <guid>http://bytemode.github.io/reading/50-2019-06-27-goland-practrice/</guid>
      <description>GoLand Tips &amp;amp; Tricks 问答 21:01:08 From Shengyou Fan : 全程英文+中文翻译 21:04:11 From Hao : Shengyou , r u come from TW ? 21:04:50 From Shengyou Fan : Yes, I’m from TW 21:10:04 From lucas : ctrl + tab 对应 mac 是？ 21:10:12 From mai yang : presentation assistant 21:10:26 From Shengyou Fan : 也是 ctrl + tab 21:14:26 From Dominic : 这种 example 自己在document中定义的话 是代码块吗 21:27:37 From lucas : 有什么办法可以在terminal中快速打开一个文件吗？ 21:27:46 From 江金 饶 to mai yang (Privately) : open xxx 21:27:50 From mai yang to 江金 饶 (Privately) : opne xxx 21:27:59 From mai yang : open xxx 21:28:01 From Dominic : open on mac or start on win 21:28:03 From Hao : Mac, open file 21:28:08 From Zhongxuan的 iPhone : Open .</description>
    </item>
    
    <item>
      <title>第 49 期 TiDB 源码阅读之 Transaction</title>
      <link>http://bytemode.github.io/reading/49-2019-06-26-tidb-transaction-reading/</link>
      <pubDate>Wed, 26 Jun 2019 21:10:00 +0800</pubDate>
      
      <guid>http://bytemode.github.io/reading/49-2019-06-26-tidb-transaction-reading/</guid>
      <description>TiDB Transaction 内容介绍 本次分享主要讲 TiDB 的事务执行过程和一些异常处理，涉及 TiDB 的 session 和 tikv 部分模块。
PDF: Source code reading of TiDB Transaction .pdf
推荐阅读  TiDB 源码阅读系列文章（十九）tikv-client（下） 三篇文章了解 TiDB 技术内幕 - 说存储 Transaction in TiDB Coprocessor in TiKV  视频回看  TiDB 源码学习之 Executor - YouTube TiDB 源码学习之 Executor - Bilibili  问题 21:17:34 From zq : 分享妹子用的是什么IDE 21:17:44 From mrj : goland 21:17:45 From Pure White : 左上角，goland 21:17:45 From tangyinpeng : goland 21:17:46 From Heng Long : goland 21:17:57 From zq : goland现在做得这么好看啦 21:18:05 From Heng Long : Meterial theme 21:18:07 From mrj : 下来主题 21:18:22 From lk : 有什么比较不错的主题吗？ 21:18:31 From Pure White : darcula 21:18:35 From mrj : 默认的就挺好的 21:20:04 From mai yang : 明天晚上将由 GoLand 布道师给我们分享 GoLand 的使用及技巧实践分享。 21:28:23 From HAITAO的 iPhone : 点查不带timestamp，直接读最新稳定版本么？ 21:28:32 From Wei Yao : 对 21:28:52 From liber xue : 双击shift 直接search 21:28:55 From Wei Yao : 最新 commited 版本 21:35:50 From HAITAO的 iPhone : 点查，实际会默认给一个当前最新的timestamp,根据这个ts，kv返回对应的版本值?</description>
    </item>
    
    <item>
      <title>第 48 期 TiDB 源码阅读之 Compiler</title>
      <link>http://bytemode.github.io/reading/48-2019-06-19-tidb-compiler-reading/</link>
      <pubDate>Wed, 19 Jun 2019 21:10:00 +0800</pubDate>
      
      <guid>http://bytemode.github.io/reading/48-2019-06-19-tidb-compiler-reading/</guid>
      <description>TiDB Compiler 内容介绍 本次分享主要讲 TiDB 的优化器框架以及具体的 SQL 执行优化原理 。主要涉及 TiDB 的 planner 模块。欢迎大家参加！
PPT: TiDB Compiler.pdf
推荐阅读  TiDB 源码阅读系列文章（七）基于规则的优化 TiDB 源码阅读系列文章（八）基于代价的优化 TiDB 源码阅读系列文章（二十一）基于规则的优化 II  视频回看  TiDB 源码学习之 Executor - YouTube TiDB 源码学习之 Executor - Bilibili  问题 22:13:46 From mai yang : rule 怎么对照文档帮助理解呢？ 22:16:31 From dqyuan : 怎么快速找到代码对应的pr？ 22:18:43 From Wei Yao : git blame 22:23:04 From kzl : Order by 是会下推到tikv吗？ 22:25:02 From Wei Yao : 除非 order by 带了 limit，要不然推下去没意义 22:25:25 From Wei Yao : 有一些情况，如果是 order by 一个索引，那就直接消除掉这个 排序操作了 22:26:07 From zhao : 有意义吧，推了之后 tidb端可以直接stream merge，不知道实现了没有 22:27:38 From Wei Yao : 是可以 stream merge, 但是现在 tidb 还没实现这个，因为优先级不是太高 22:30:42 From Wei Yao : stream merge 主要是可以节省一些内存，避免 order by 太多导致 tidb oom 22:30:56 From Heng Long : 嗯，会让 tikv 的压力变大 22:34:28 From hezhiyong : limit offset 分页性能不好 22:34:53 From hezhiyong : 有好变通改写方法没 22:35:52 From hezhiyong : limit offset 会有下推到tikv么 22:36:19 From Wei Yao : limit offset 没办法的，这个是全局的 offset 22:36:40 From Wei Yao : tikv 并不知道自己的 offset 在全局的 offset 是多少 22:37:05 From Wei Yao : 这个其他数据库其实也一样 22:37:37 From hezhiyong : 那就是这个数据就是要全拿到tidb层在来过滤 22:37:38 From hezhiyong : 是吧 22:39:27 From Hao’s iPad : 喝口水吧 22:45:35 From zhao : 这个skyline prune有相关的资料吗 22:45:41 From zhao : paper之类的 22:47:09 From Wei Yao : 我记得暂时还没有 public 22:47:20 From Wei Yao : skyline pruning 就是消除一些路径 23:04:22 From mai yang : 怎么快速找到代码对应的pr？git blame 这个可以演示一下吗？ 23:06:42 From tangenta : github 上面看文件的时候有个选项是 blame，那里应该比较清晰 23:09:44 From mai yang : github 上面看文件的时候有个选项是 blame，那里应该比较清晰 —— 这个不错，看到了。</description>
    </item>
    
    <item>
      <title>第 47 期 TiDB 源码阅读之 Executor</title>
      <link>http://bytemode.github.io/reading/47-2019-06-12-tidb-exector-reading/</link>
      <pubDate>Wed, 12 Jun 2019 21:10:00 +0800</pubDate>
      
      <guid>http://bytemode.github.io/reading/47-2019-06-12-tidb-exector-reading/</guid>
      <description> TiDB Executor 内容介绍 本次分享主要讲 TiDB 中 insert/update/delete/select, 以及 DDL 等是如何执行的，以及涉及到相关模块。大概会涉及以下模块：
 executor distsql ddl  PPT: TiDB Executor 源码阅读.pdf
推荐阅读  Select 语句概览 INSERT 语句详解 DDL 源码解析  视频回看  TiDB 源码学习之 Executor - YouTube TiDB 源码学习之 Executor - Bilibili  PPT: https://github.com/developer-learning/reading-go/files/3281080/TiDB.Executor.pdf
问题  表的信息是怎么存的呢  id的生成规则是什么  如果索引里面不保存handle_id，那怎么根据索引找到这行数据呢  索引字段很大会不会有问题，作为id的一部分的话 单条6m的限制是怎么计算出来的？还是压力测出来的？ ddl时，job放到tikv的队列，tikv是分布式的，job具体是放到哪个tikv上的呢？ 并行ddl 如何跑 tikv整体上可以看成一个kv store region这部分概念可以配合hbase去看看能更好的理解 难道own tidb server要遍历所有的tikv server上的queue，去取ddl的job？ tidb 的统计信息也是放一个表里面，每次parse 都会去拿这个信息，这样的话请求到一个region,这个表是不是很容易成为热点  观看视频   </description>
    </item>
    
    <item>
      <title>第 46 期 TiDB 源码阅读之概览</title>
      <link>http://bytemode.github.io/reading/46-2019-06-05-tidb-overview-reading/</link>
      <pubDate>Wed, 05 Jun 2019 21:10:00 +0800</pubDate>
      
      <guid>http://bytemode.github.io/reading/46-2019-06-05-tidb-overview-reading/</guid>
      <description>TiDB Source Code Overview 视频回看  TiDB 源码学习之 Source Code Overview - YouTube TiDB 源码学习之 Source Code Overview - Bilibili  意见反馈  【Go夜读】《TiDB Source Code Overview》反馈  chat 答疑 20:54:52 From mai yang : 大家好，欢迎大家前来参加 Go 夜读&amp;amp;TiDB 源码学习！ 21:22:34 From nange : Session 怎么初始化的？ 21:22:46 From ccong deng : 每个连接都是跟一个session对象对应么？ 21:22:48 From jeffery : session主要包含什么？ 21:22:59 From jeffery : 譬如： 21:23:01 From Wei Yao : 对，一个链接一个 session 21:23:09 From Wei Yao : 具体包含什么，可以大家自己去看了 21:23:17 From Wei Yao : 这个线上不可能所有都讲的 21:23:25 From jeffery : 好的，谢谢了 21:31:00 From Wei Yao : 大家如果对语法分析，词法分析感兴趣，可以去看看 yacc 跟 lex 21:31:10 From hezhiyong : parser 这一层不是使用mysql的parser吗 21:31:17 From Wei Yao : 不，我们自己写的 21:31:56 From hezhiyong : mysql 的语法解析是在那一步用到了？ 21:32:01 From tianyi wang : select coalesce（）中coalesce是在fields里面吗 21:32:10 From Wei Yao : 我们的语法解析就是兼容 mysql， 21:32:12 From window930030@gmail.</description>
    </item>
    
    <item>
      <title>第 45 期 goim 架构设计与源码分析</title>
      <link>http://bytemode.github.io/reading/45-2019-05-30-goim-reading/</link>
      <pubDate>Thu, 30 May 2019 21:10:00 +0800</pubDate>
      
      <guid>http://bytemode.github.io/reading/45-2019-05-30-goim-reading/</guid>
      <description> 观看视频   </description>
    </item>
    
    <item>
      <title>第 44 期 Go map 源码阅读分析</title>
      <link>http://bytemode.github.io/reading/44-2019-05-29-go-map-reading/</link>
      <pubDate>Wed, 29 May 2019 21:10:00 +0800</pubDate>
      
      <guid>http://bytemode.github.io/reading/44-2019-05-29-go-map-reading/</guid>
      <description> 观看视频   </description>
    </item>
    
    <item>
      <title>第 43 期 gomonkey 框架设计与应用实践</title>
      <link>http://bytemode.github.io/reading/43-2019-05-23-gomonkey-framework-design-and-practives/</link>
      <pubDate>Thu, 23 May 2019 21:30:00 +0800</pubDate>
      
      <guid>http://bytemode.github.io/reading/43-2019-05-23-gomonkey-framework-design-and-practives/</guid>
      <description> 观看视频   </description>
    </item>
    
    <item>
      <title>第 42 期 An Introduction to Failpoint Design</title>
      <link>http://bytemode.github.io/reading/42-2019-05-16-go-failpoint-design/</link>
      <pubDate>Thu, 16 May 2019 21:00:00 +0800</pubDate>
      
      <guid>http://bytemode.github.io/reading/42-2019-05-16-go-failpoint-design/</guid>
      <description> 观看视频   </description>
    </item>
    
    <item>
      <title>第 41 期 golint 及 golangci-lint 的介绍和使用</title>
      <link>http://bytemode.github.io/reading/41-2019-05-12-golint-golangci-lint/</link>
      <pubDate>Sun, 12 May 2019 20:00:00 +0800</pubDate>
      
      <guid>http://bytemode.github.io/reading/41-2019-05-12-golint-golangci-lint/</guid>
      <description> 观看视频   </description>
    </item>
    
    <item>
      <title>第 40 期 atomic.Value 的使用和源码分析</title>
      <link>http://bytemode.github.io/reading/40-2019-04-27-atomic-value-in-go/</link>
      <pubDate>Sat, 27 Apr 2019 21:05:00 +0800</pubDate>
      
      <guid>http://bytemode.github.io/reading/40-2019-04-27-atomic-value-in-go/</guid>
      <description> 观看视频   </description>
    </item>
    
    <item>
      <title>第 39 期 init function 使用分析</title>
      <link>http://bytemode.github.io/reading/39-2019-04-18-init-function-in-go/</link>
      <pubDate>Thu, 18 Apr 2019 21:05:00 +0800</pubDate>
      
      <guid>http://bytemode.github.io/reading/39-2019-04-18-init-function-in-go/</guid>
      <description> 观看视频   </description>
    </item>
    
    <item>
      <title>第 38 期 kubernetes scheduler 源码阅读</title>
      <link>http://bytemode.github.io/reading/38-2019-04-13-k8s-scheduler-reading/</link>
      <pubDate>Sat, 13 Apr 2019 21:05:00 +0800</pubDate>
      
      <guid>http://bytemode.github.io/reading/38-2019-04-13-k8s-scheduler-reading/</guid>
      <description> 观看视频   </description>
    </item>
    
    <item>
      <title>第 37 期 从 serverless 的一个设计说起</title>
      <link>http://bytemode.github.io/reading/37-2019-04-01-talk-from-serverless-in-apache-pulsar/</link>
      <pubDate>Mon, 01 Apr 2019 21:05:00 +0800</pubDate>
      
      <guid>http://bytemode.github.io/reading/37-2019-04-01-talk-from-serverless-in-apache-pulsar/</guid>
      <description> 参考资料  预习材料 pulsar-effectively-once  观看视频   </description>
    </item>
    
    <item>
      <title>第 36 期 k8s context 实践源码阅读</title>
      <link>http://bytemode.github.io/reading/36-2019-03-28-reading-k8s-context/</link>
      <pubDate>Thu, 28 Mar 2019 21:05:00 +0800</pubDate>
      
      <guid>http://bytemode.github.io/reading/36-2019-03-28-reading-k8s-context/</guid>
      <description> 实践  WithValue WithCancel WithTimeout  WithDeadline 基本上没有用到。
参考资料  How to correctly use context.Context in Go 1.7 How to correctly use package context 视频笔记：如何正确使用 Context - Jack Lindamood  观看视频   </description>
    </item>
    
    <item>
      <title>第 35 期 context 源码阅读</title>
      <link>http://bytemode.github.io/reading/35-2019-03-21-reading-context/</link>
      <pubDate>Thu, 21 Mar 2019 21:05:00 +0800</pubDate>
      
      <guid>http://bytemode.github.io/reading/35-2019-03-21-reading-context/</guid>
      <description> 预习材料 第 35 期 Go 夜读之《context 包源码阅读》预习资料 #191
观看视频   </description>
    </item>
    
    <item>
      <title>第 34 期 Go 夜读之 plan9 汇编入门，带你打通应用和底层 by Xargin</title>
      <link>http://bytemode.github.io/reading/34-2019-03-16-plan9-guide/</link>
      <pubDate>Sat, 16 Mar 2019 21:05:00 +0800</pubDate>
      
      <guid>http://bytemode.github.io/reading/34-2019-03-16-plan9-guide/</guid>
      <description>2019.3.16 晚上 21 点 ~ 23点
直播过程中的文字讨论 （如有涉及到隐私，请告知） 21:08:32	From xiong hekuan : 几乎没有 21:08:47	From amatist Kurisu : 大佬开下麦... 21:09:02	From Laily Long : 能听到 21:09:02	From xiong hekuan : 可以 21:09:03	From 何翔宇 : 可以 21:09:06	From xiye : 能听到 21:09:09	From haoc7 : 听到了 21:09:12	From 星星 : 挺清楚的 21:11:01	From amatist Kurisu : ok 21:13:57	From panda : 👍 21:15:40	From albert’s iPhoneSE : 32位都差不多复杂 21:28:15	From 红红火火 : 不太好理解 21:28:24	From dongzerun : rax rbx ….</description>
    </item>
    
    <item>
      <title>第 1 期每日阅读特训营</title>
      <link>http://bytemode.github.io/reading/1-2019-03-14-daily-reading/</link>
      <pubDate>Thu, 14 Mar 2019 09:10:00 +0800</pubDate>
      
      <guid>http://bytemode.github.io/reading/1-2019-03-14-daily-reading/</guid>
      <description>阅读清单    标题 阅读者     漫话：如何给女朋友解释为什么有些网站域名不以 www 开头 mai   LeetCode 的刷题利器（伪装到老板都无法 diss 你没有工作） mai   深入 GO 语言文本类型 ch   k8s cpu 资源限制 k8s 内存资源限制 Jason   Golang 之轻松化解 defer 的温柔陷阱 关于 go 语言中的延迟执行函数 Littlesqx    “漫话”的阅读笔记  域名的一个重要功能——为数字化的互联网资源提供易于记忆的名称。 域名具有唯一性。 www，其实是 World Wide Web 的缩写，中文翻译为万维网 互联网并不等同万维网（WWW），万维网只是一个基于超文本相互链接而成的全球性系统，且是互联网所能提供的服务其中之一。 为了区分互联网中的各种应用，就有了不同的子域名，比如互联网就以 www 作为子域名，文件传输以 ftp 作为子域名，电子邮件以 mail 作为子域名。 正是因为万维网是互联网中最重要的一部分，很多域名的最主要用途也是搭建 web 网站，所以，会有很多公司直接忽略 www。 通用顶级域（英语：Generic top-level domain，缩写为 gTLD），是互联网名称与数字地址分配机构（IANA）管理的顶级域（TLD）之一。该机构专门负责互联网的域名系统。 域名支持中文，并且域名中也已经支持颜文字了。“👀.</description>
    </item>
    
    <item>
      <title>第 33 期 Go 夜读之 Go defer 和逃逸分析</title>
      <link>http://bytemode.github.io/reading/33-2019-03-07-defer-in-go/</link>
      <pubDate>Thu, 07 Mar 2019 21:05:00 +0800</pubDate>
      
      <guid>http://bytemode.github.io/reading/33-2019-03-07-defer-in-go/</guid>
      <description> 2019.3.7 晚上
观看视频   </description>
    </item>
    
    <item>
      <title>第 32 期 Go 夜读之 etcd raft 源码阅读</title>
      <link>http://bytemode.github.io/reading/32-2019-03-02-etcd-raft/</link>
      <pubDate>Sat, 02 Mar 2019 21:05:00 +0800</pubDate>
      
      <guid>http://bytemode.github.io/reading/32-2019-03-02-etcd-raft/</guid>
      <description> etcd raft 阅读
etcd 版本：3.3.10
2019.3.2 晚上
总结 etcd里的raft模块只实现了raft共识算法，而像消息的网络传输，数据存储都由上层应用来完成。
下面是各个文件（夹）的功能简介：
 raftpb  用Protocol Buffer定义了一些需要序列化的数据结构，比如Entry和Message。
 log_unstable.go  unstable数据结构表示用于还没有被用户层持久化的数据，它维护了两部分内容snapshot和entries。
 storage.go  这个文件定义了一个Storage接口，应用层需要实现这个接口，以提供存储和查询日志的能力。
 log.go  维护本地日志信息。其中的committed和applied分别表示已提交和已经应用到状态机的日志索引。
 progress.go  Leader节点通过Progress这个数据结构来追踪一个follower的状态，并根据Progress里的信息来决定每次同步的日志项。
 raft.go  Raft协议的具体实现就在这个文件里。其中最重要的就是Step函数，它用来处理不同的消息。所以以后当我们想知道raft对某种消息的处理逻辑时，到这里找就对了。
 node.go  node的主要作用是应用层和共识模块（raft）的衔接。将应用层的消息传递给底层共识模块，并将底层共识模块共识后的结果反馈给应用层。
参考资料  深入浅出 Raft - 基本概念 深入浅出 Raft - Membership Change 深入浅出 Raft - Leader 选举 深入浅出 Raft - Optimization Raft在etcd中的实现 etcd contrib Etcd超全解：原理阐释及部署设置的最佳实践  观看视频   </description>
    </item>
    
    <item>
      <title>第 31 期 Go 夜读之 flag 包源码阅读</title>
      <link>http://bytemode.github.io/reading/31-2019-02-23-flag/</link>
      <pubDate>Sat, 23 Feb 2019 21:00:00 +0800</pubDate>
      
      <guid>http://bytemode.github.io/reading/31-2019-02-23-flag/</guid>
      <description> Go 标准包阅读
Go 版本：go 1.11.5
总结  *v.URL = *u flag 下有 package flag_test？？ init 中定义相同的 stringvar ； 当一个文件中出现多个 init 函数时，他们都会被加载，并且以 init 出现在文件中的前后顺序执行。 type Value interface { String() string Set(string) error } type Getter interface { Value Get() interface{} } type boolFlag interface { Value IsBoolFlag() bool } strconv.ParseBool 的返回值可以被利用
v, err := strconv.ParseBool(s) *b = boolValue(v) return err  参考资料  Go 语言中值 receiver 和指针 receiver 的对比（收集的一些资料）  观看视频   </description>
    </item>
    
    <item>
      <title>第 30 期 Go 夜读之 go mod 源码阅读 part 4</title>
      <link>http://bytemode.github.io/reading/30-2019-02-16-go-mod-part-4/</link>
      <pubDate>Sat, 16 Feb 2019 21:00:00 +0800</pubDate>
      
      <guid>http://bytemode.github.io/reading/30-2019-02-16-go-mod-part-4/</guid>
      <description> Go 标准包阅读
Go 版本：go 1.11.5
net/http  `` 换行  本期没有视频回放。
观看视频   </description>
    </item>
    
    <item>
      <title>第 29 期 Go opentracing jaeger 集成及源码分析</title>
      <link>http://bytemode.github.io/reading/29-2019-01-23-opentracing-jaeger-in-go/</link>
      <pubDate>Wed, 23 Jan 2019 21:00:00 +0800</pubDate>
      
      <guid>http://bytemode.github.io/reading/29-2019-01-23-opentracing-jaeger-in-go/</guid>
      <description>Go opentracing jaeger 集成及源码分析 一、分布式追踪论文 论文地址：http://bigbully.github.io/Dapper-translation/
为什么要用分布式追踪  当代的互联网的服务，通常都是用复杂的、大规模分布式集群来实现的。 互联网应用构建在不同的软件模块集上，这些软件模块，有可能是由不同的团队开发、 可能使用不同的编程语言来实现、有可能布在了几千台服务器，横跨多个不同的数据中心。 因此，就需要一些可以帮助理解系统行为、用于分析性能问题的工具。
 分布式系统调用过程 使用分布式追踪要留意哪些问题  低损耗
 跟踪系统对在线服务的影响应该做到足够小。
 应用透明
 对于应用的程序员来说，是不需要知道有跟踪系统这回事的。
  二、Opentracing简介 Opentracing的作用  OpenTracing通过提供平台无关、厂商无关的API，使得开发人员能够方便的添加（或更换）追踪系统的实现。  可以很自由的在不同的分布式追 踪系统中切换
 不负责具体实现
  Opentracing主要组成  一个Trace &amp;gt; 一个trace代表了一个事务或者流程在（分布式）系统中的执行过程
 Span &amp;gt; 记录Trace在执行过程中的信息
 无限极分类 &amp;gt; 服务与服务之间使用无限极分类的方式，通过HTTP头部或者请求地址传输到最低层，从而把整个调用链串起来。
  Jaeger-client的实现 Jaeger-client源码 提取  为什么要提取 &amp;gt; 主要作用是为了找到父亲
 从哪里提取 &amp;gt; 进程内，不同进程之间各自约定 &amp;gt; 粟子：github.com/opentracing-contrib/go-stdlib/nethttp/server.go P86
 提取什么 &amp;gt; traceid:spanid:parentid:是否采集 &amp;gt; uber-trace-id=157b74261b51d917:157b74261b51d917:0:1 &amp;gt; github.</description>
    </item>
    
    <item>
      <title>第 28 期 Go 夜读之 go mod 源码阅读 part 3</title>
      <link>http://bytemode.github.io/reading/28-2019-01-17-go-mod-part-3/</link>
      <pubDate>Thu, 17 Jan 2019 20:05:00 +0800</pubDate>
      
      <guid>http://bytemode.github.io/reading/28-2019-01-17-go-mod-part-3/</guid>
      <description> Go 标准包阅读
Go 版本：go 1.11.5
学到的内容  json:&amp;quot;,omitempty&amp;quot;   方法一：
if path[len(path)-1] == &amp;#39;/&amp;#39; { return fmt.Errorf(&amp;#34;trailing slash&amp;#34;) } 方法二：
strings.HasSuffix(path, &amp;#34;/&amp;#34;) benchmark
   方法一：
strings.TrimSuffix(pathMajor, &amp;#34;-unstable&amp;#34;) 方法二：
i := len(path) if strings.HasSuffix(path, &amp;#34;-unstable&amp;#34;) { i -= len(&amp;#34;-unstable&amp;#34;) } benchmark
 if i := strings.Index(arg, &amp;#34;@&amp;#34;); i &amp;gt;= 0 { path, vers = arg[:i], arg[i+1:] }  也可以用 split(arg, &amp;quot;@&amp;quot;) 来实现。
观看视频   </description>
    </item>
    
    <item>
      <title>第 27 期 Go 夜读之 go mod 源码阅读 part 2</title>
      <link>http://bytemode.github.io/reading/27-2019-01-10-go-mod-part-2/</link>
      <pubDate>Thu, 10 Jan 2019 21:05:00 +0800</pubDate>
      
      <guid>http://bytemode.github.io/reading/27-2019-01-10-go-mod-part-2/</guid>
      <description>Go 标准包阅读
Go 版本：go 1.11.5
学到的内容 1. mf := new(modfile.File) 2. lineno++ 感觉是无用的代码？ dep.go 中 ParseGopkgLock 方法第48行有用到 lineno ，会打印出 strconv.Unquote 解析错误的文件名和行号
if len(val) &amp;gt;= 2 &amp;amp;&amp;amp; val[0] == &amp;#39;&amp;#34;&amp;#39; &amp;amp;&amp;amp; val[len(val)-1] == &amp;#39;&amp;#34;&amp;#39; { q, err := strconv.Unquote(val) // Go unquoting, but close enough for now  if err != nil { return nil, fmt.Errorf(&amp;#34;%s:%d: invalid quoted string: %v&amp;#34;, file, lineno, err) } val = q } 其他几个文件可能是为了保持一致，或者为了将来输出错误信息特意保留的。其他文件里面的 lineno 没有地方引用，大家在阅读代码时会产生困惑，建议用空白符_来替代。</description>
    </item>
    
    <item>
      <title>第 26 期 Go 夜读之手把手教你基于 Github&#43;Netlify 构建自动化持续集成的技术团队博客</title>
      <link>http://bytemode.github.io/reading/26-2019-01-03-blog-with-github-netlify/</link>
      <pubDate>Thu, 03 Jan 2019 21:15:00 +0800</pubDate>
      
      <guid>http://bytemode.github.io/reading/26-2019-01-03-blog-with-github-netlify/</guid>
      <description> Github Netlify 观看视频   </description>
    </item>
    
    <item>
      <title>第 25 期 TSDB 引擎介绍，对比及存储细节</title>
      <link>http://bytemode.github.io/reading/25-2018-12-27-tsdb/</link>
      <pubDate>Thu, 27 Dec 2018 20:35:00 +0800</pubDate>
      
      <guid>http://bytemode.github.io/reading/25-2018-12-27-tsdb/</guid>
      <description> TSDB 引擎介绍，对比及存储细节  OpenTSDB InfluxDB Druid  观看视频   </description>
    </item>
    
    <item>
      <title>第 24 期 go mod 源码阅读 part 1</title>
      <link>http://bytemode.github.io/reading/24-2018-12-23-go-mod-part-1/</link>
      <pubDate>Sun, 23 Dec 2018 21:05:00 +0800</pubDate>
      
      <guid>http://bytemode.github.io/reading/24-2018-12-23-go-mod-part-1/</guid>
      <description>Go 标准包阅读
Go 版本：go 1.11.5
观看视频   阅读重点  os.Stat filepath.SplitList os.Getwd() switch sync.Once os.IsNotExist(errMod) MustQuote AutoQuote modcmd.runGraph
format := func(m module.Version) string { if m.Version == &amp;#34;&amp;#34; { return m.Path } return m.Path + &amp;#34;@&amp;#34; + m.Version } sort.Slice
  什么是 go mod module 是相关 Go 依赖包的集合。module 是源代码交换和版本控制的单元。go 工具链会直接支持使用 go module，其功能包含记录和解析对其他第三方包的依赖项。模块将会替换旧的基于 $GOPATH 的模式
目前 Go1.11 是初步支持，后续建议持续观望一下。详见 godoc
开关 由于当前还在试验阶段，需要设置环境变量 GO111MODULE=on，才能够使用 go mod。支持一下选项：
 off：禁用 go module，按原有 $GOPATH、vendor 的寻址逻辑 on：启用 go module auto：若当前不在 $GOPATH 下，且当前目录的根目录下含有 go.</description>
    </item>
    
    <item>
      <title>第 23 期 Drone 简单介绍和部分源码分析</title>
      <link>http://bytemode.github.io/reading/23-2018-12-13-drone-guide/</link>
      <pubDate>Thu, 13 Dec 2018 20:35:00 +0800</pubDate>
      
      <guid>http://bytemode.github.io/reading/23-2018-12-13-drone-guide/</guid>
      <description> 观看视频   参考资料  基于 gogs/gitlab 和 drone 搭建的 CI/CD 平台 Drone 源码分析之同步 repos 的策略研讨 Drone 源码分析之数据库初始化  </description>
    </item>
    
    <item>
      <title>第 22 期 Go 开发工具讨论</title>
      <link>http://bytemode.github.io/reading/22-2018-12-06-go-ide-discuss/</link>
      <pubDate>Thu, 06 Dec 2018 20:30:00 +0800</pubDate>
      
      <guid>http://bytemode.github.io/reading/22-2018-12-06-go-ide-discuss/</guid>
      <description> 观看视频   </description>
    </item>
    
    <item>
      <title>第 21 期 Go errors 处理及 zap 源码分析</title>
      <link>http://bytemode.github.io/reading/21-2018-11-28-errors-in-go/</link>
      <pubDate>Wed, 28 Nov 2018 11:13:59 +0800</pubDate>
      
      <guid>http://bytemode.github.io/reading/21-2018-11-28-errors-in-go/</guid>
      <description> 观看视频   </description>
    </item>
    
    <item>
      <title>第 20 期 go test 及测试覆盖率</title>
      <link>http://bytemode.github.io/reading/20-2018-11-15-go-test/</link>
      <pubDate>Thu, 15 Nov 2018 11:19:26 +0800</pubDate>
      
      <guid>http://bytemode.github.io/reading/20-2018-11-15-go-test/</guid>
      <description> 观看视频   </description>
    </item>
    
    <item>
      <title>第 19 期 如何开发一个简单高性能的http router及gorouter源码分析</title>
      <link>http://bytemode.github.io/reading/19-2018-11-08-http-router-in-go/</link>
      <pubDate>Thu, 08 Nov 2018 11:49:10 +0800</pubDate>
      
      <guid>http://bytemode.github.io/reading/19-2018-11-08-http-router-in-go/</guid>
      <description> 观看视频   </description>
    </item>
    
    <item>
      <title>第 18 期 去中心化加密通信框架 CovenantSQL/DH-RPC的设计</title>
      <link>http://bytemode.github.io/reading/18-2018-09-27-covenantsql-dh-rpc/</link>
      <pubDate>Thu, 27 Sep 2018 11:19:54 +0800</pubDate>
      
      <guid>http://bytemode.github.io/reading/18-2018-09-27-covenantsql-dh-rpc/</guid>
      <description> 观看视频   </description>
    </item>
    
    <item>
      <title>第 17 期 grpc 开发及 grpcp 的源码分析</title>
      <link>http://bytemode.github.io/reading/17-2018-09-20-grpcp/</link>
      <pubDate>Thu, 20 Sep 2018 11:36:54 +0800</pubDate>
      
      <guid>http://bytemode.github.io/reading/17-2018-09-20-grpcp/</guid>
      <description> 观看视频   </description>
    </item>
    
    <item>
      <title>第 16 期 gateway-reading</title>
      <link>http://bytemode.github.io/reading/16-2018-09-06-gateway-reading/</link>
      <pubDate>Thu, 06 Sep 2018 11:49:10 +0800</pubDate>
      
      <guid>http://bytemode.github.io/reading/16-2018-09-06-gateway-reading/</guid>
      <description>OpenFaaS的Gateway是一个golang实现的请求转发的网关，在这个网关服务中，主要有以下几个功能：
 UI 部署函数 监控 自动伸缩  架构分析 从图中可以发现，当Gateway作为一个入口，当CLI或者web页面发来要部署或者调用一个函数的时候，Gateway会将请求转发给Provider，同时会将监控指标发给Prometheus。AlterManager会根据需求，调用API自动伸缩函数。
源码分析 依赖 github.com/gorilla/mux github.com/nats-io/go-nats-streaming github.com/nats-io/go-nats github.com/openfaas/nats-queue-worker github.com/prometheus/client_golang mux 是一个用来执行http请求的路由和分发的第三方扩展包。
go-nats-streaming，go-nats，nats-queue-worker这三个依赖是异步函数的时候才会用到，在分析queue-worker的时候有说到Gateway也是一个发布者。
client_golang是Prometheus的客户端。
项目结构 ├── Dockerfile ├── Dockerfile.arm64 ├── Dockerfile.armhf ├── Gopkg.lock ├── Gopkg.toml ├── README.md ├── assets ├── build.sh ├── handlers │ ├── alerthandler.go │ ├── alerthandler_test.go │ ├── asyncreport.go │ ├── baseurlresolver_test.go │ ├── basic_auth.go │ ├── basic_auth_test.go │ ├── callid_middleware.go │ ├── cors.go │ ├── cors_test.go │ ├── forwarding_proxy.go │ ├── forwarding_proxy_test.</description>
    </item>
    
    <item>
      <title>第 15 期 多路复用资源池组件剖析</title>
      <link>http://bytemode.github.io/reading/15-2018-08-23-pool-workshop-in-go/</link>
      <pubDate>Thu, 23 Aug 2018 11:49:10 +0800</pubDate>
      
      <guid>http://bytemode.github.io/reading/15-2018-08-23-pool-workshop-in-go/</guid>
      <description>2018-08-23 22:00:00 分享会之后的答疑。
 源代码地址：pool#workshop
一个网友在分享会之后的个人理解：对是独占资源对象的复用，提升了最后的 qps，独占式方法 TestChanPool() 函数中使用了从资源池获取 worker 对象，执行完毕后再放回资源池，如果获取不到则阻塞等待，因此，100 000 请求，每个请求占用 10ms，可用 worker 对象 50 个，则最后 100 000*10/50 =20s ,视频中测试结果也显示 21s 符合预期。而 TestWorkshop() 函数中使用回调函数对 worker 进行加锁，每个线程使用的那一刻是 worker 对象是被独占的，而后续的 do{sleep(10ms)} 是并发执行的，并且根据每个 worker 同时执行的 do 的任务数，进行负载均衡，所以最后测试性能 QPS 能够有 20 倍的提升。
 workshop 中每个协程只在获得 worker 的那一刻是互斥的，且不会从池子中移除，通过状态统计达到资源的负载均衡。在业务上真正使用资源时其实是无锁状态，所以能被其他协程同时使用，进而吞吐量提升。业务逻辑耗时越长，相比独占式资源池的吞吐量优势越显著。本机测试 50 个资源 10ms 时可提升 20 倍。
 为什么不使用轮询使用资源，代码实现会更简单？  实际场景中每次业务逻辑耗时不相同，轮询并不能保证真的负载均衡。尤其是当突发异常时，可能导致负载失衡。
 为什么长连接异步通信不使用一条连接而是连接池？ 说到长连接异步通信，为什么不使用一条连接而是连接池，其实涉及到多条连接抢占带宽和 TCP 丢包后速率下降的问题。这对于下载场景（迅雷就是这么做的）和使用共享云主机的场景比较有用。 具体可以看这篇文章：为什么多 TCP 连接比单TCP连接传输快
 以前在做加速的一项就是多线程下载，开启多个 tcp 连接，同时下载，比只有一个连接下载快多了。
 workshop 的使用场景 使用 workshop 的前提就是该资源可以被同时使用，比如长连接的异步IO通信。</description>
    </item>
    
    <item>
      <title>第 14 期 sync.Pool 源码分析及适用场景</title>
      <link>http://bytemode.github.io/reading/14-2018-08-17-sync-pool-reading/</link>
      <pubDate>Fri, 17 Aug 2018 11:49:10 +0800</pubDate>
      
      <guid>http://bytemode.github.io/reading/14-2018-08-17-sync-pool-reading/</guid>
      <description> Go 标准包阅读
观看视频   </description>
    </item>
    
    <item>
      <title>第 13 期 Kubernetes 入门指南</title>
      <link>http://bytemode.github.io/reading/13-2018-08-09-kubernetes-guide/</link>
      <pubDate>Thu, 09 Aug 2018 00:00:08 +0800</pubDate>
      
      <guid>http://bytemode.github.io/reading/13-2018-08-09-kubernetes-guide/</guid>
      <description> 观看视频   </description>
    </item>
    
    <item>
      <title>第 12 期 golang 中 goroutine 的调度</title>
      <link>http://bytemode.github.io/reading/12-2018-08-02-goroutine-gpm/</link>
      <pubDate>Thu, 02 Aug 2018 11:49:10 +0800</pubDate>
      
      <guid>http://bytemode.github.io/reading/12-2018-08-02-goroutine-gpm/</guid>
      <description>郑宝杨(boya) 2018-08-01 listomebao@gmail.com
阅读源码前可以阅读的资料  Goroutine背后的系统知识 golang源码剖析-雨痕老师 go-intervals 也谈goroutine调度器  golang的调度模型概览 调度的机制用一句话描述：
runtime准备好G,P,M，然后M绑定P，M从各种队列中获取G，切换到G的执行栈上并执行G上的任务函数，调用goexit做清理工作并回到M，如此反复。
基本概念 M（machine）  M代表着真正的执行计算资源，可以认为它就是os thread（系统线程）。 M是真正调度系统的执行者，每个M就像一个勤劳的工作者，总是从各种队列中找到可运行的G，而且这样M的可以同时存在多个。 M在绑定有效的P后，进入调度循环，而且M并不保留G状态，这是G可以跨M调度的基础。  P（processor）  P表示逻辑processor，是线程M的执行的上下文。 P的最大作用是其拥有的各种G对象队列、链表、cache和状态。  G（goroutine）  调度系统的最基本单位goroutine，存储了goroutine的执行stack信息、goroutine状态以及goroutine的任务函数等。 在G的眼中只有P，P就是运行G的“CPU”。 相当于两级线程  线程实现模型 来自Go并发编程实战
 +-------+ +-------+ | KSE | | KSE | +-------+ +-------+ | | 内核空间 - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - | | 用户空间 +-------+ +-------+ | M | | M | +-------+ +-------+ | | | | +------+ +------+ +------+ +------+ | P | | P | | P | | P | +------+ +------+ +------+ +------+ | | | | | | | | | +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ | G | | G | | G | | G | | G | | G | | G | | G | | G | +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---+ +---+   KSE（Kernel Scheduling Entity）是内核调度实体</description>
    </item>
    
    <item>
      <title>第 11 期 Golang 代码质量持续检测实践</title>
      <link>http://bytemode.github.io/reading/11-2018-07-26-golang-jenkins-sonarqube/</link>
      <pubDate>Thu, 26 Jul 2018 00:00:00 +0800</pubDate>
      
      <guid>http://bytemode.github.io/reading/11-2018-07-26-golang-jenkins-sonarqube/</guid>
      <description> 观看视频   </description>
    </item>
    
    <item>
      <title>第 10 期 2018-06-28 线下活动</title>
      <link>http://bytemode.github.io/reading/10-2018-06-28-net-http-part4/</link>
      <pubDate>Thu, 28 Jun 2018 11:49:10 +0800</pubDate>
      
      <guid>http://bytemode.github.io/reading/10-2018-06-28-net-http-part4/</guid>
      <description>  参与人数: 10 人
 Go 标准包阅读  Go版本：go 1.10.2  net包  http/server.go http/request.go textproto/reader.go  读取位置  textproto/reader.go(140行)  问题  1.各个系统的回车换行符区别
  注意:10.13及其以上是macOS系统   2.URI，URL和URN的区别
  查看详情   3.HTTP CONNECT方法介绍
 会议讨论小结
	可以建立一个代理服务器到目标服务器的透明通道（tcp连接通道），中间完全不会对数据做任何处理，直接转发（支持https，一种翻墙的手段，专线独享）   HTTP代理协议 HTTP/1.1的CONNECT方法   4.peek读取字节内部实现
  这里先peek获取流数据(注意：这里没有对Peek的错误进行处理，而是根据是否Buffered读取到数据来判断错误) 为什么没有对Peek的错误进行处理呢？主要是因Peek失败了也有可能不会返回错误
	golang读取字节表现形式是阻塞式的，但其实底层是用了非阻塞式的NIO，如果没有读取到数据会定时轮询读取    5.http header尾部的符号什么情况下会存在\n\n的情况？(待解决，欢迎在下面评论)
 看源码发现hearder结尾会存在\r\n\r\n和\n\n两种字符情况
网络上查资料发现只会存在\r\n\r\n
观看视频    TODO
  相关链接  uri和url的详细规范 扒一扒HTTP的构成 20180628直播视频  </description>
    </item>
    
    <item>
      <title>第 9 期 2018-06-14 线下活动</title>
      <link>http://bytemode.github.io/reading/9-2018-06-14-net-http-part3/</link>
      <pubDate>Thu, 14 Jun 2018 11:49:10 +0800</pubDate>
      
      <guid>http://bytemode.github.io/reading/9-2018-06-14-net-http-part3/</guid>
      <description>参与人数: 12 人
 Go 标准包阅读
Go 版本：go 1.10.2
net/http  server.go h2_bundle.go  问题  WriteHeader(statusCode int)   要先调用 header.set() 再调用 WriteHeader() 然后调用 Write()  如果在调用 Write() 之后，还有比较多的逻辑要处理，则一定要紧跟着马上调一下 Flush()  然后调用 Flush()   HTTP2 不支持 Hijacker
 使用了 Hijacker 之后不能再使用 Request.Body
type Hijacker interface { // After a call to Hijack, the original Request.Body must not be used. 	Hijack() (net.Conn, *bufio.ReadWriter, error) } The returned bufio.</description>
    </item>
    
    <item>
      <title>第 8 期 2018-05-31 线下活动 - Go 标准包阅读</title>
      <link>http://bytemode.github.io/reading/8-2018-05-31-net-http-part2/</link>
      <pubDate>Thu, 31 May 2018 11:49:10 +0800</pubDate>
      
      <guid>http://bytemode.github.io/reading/8-2018-05-31-net-http-part2/</guid>
      <description>参与人数: 10 人
 Go 标准包阅读
Go 版本：go 1.10.2
net/http  server.go  问题  func (s *Server) doKeepAlives() bool { return atomic.LoadInt32(&amp;amp;s.disableKeepAlives) == 0 &amp;amp;&amp;amp; !s.shuttingDown() }  为什么要用 atomic.LoadInt32(&amp;amp;s.disableKeepAlives) == 0 ？
原子操作比用锁更节约一点性能。
 server.go#Shutdown 不保险
 panicChan := make(chan interface{}, 1)
panicChan := make(chan interface{}, 1) go func() { defer func() { if p := recover(); p != nil { panicChan &amp;lt;- p } }() h.</description>
    </item>
    
    <item>
      <title>第 7 期 2018-05-24 线下活动 - Go 标准包阅读</title>
      <link>http://bytemode.github.io/reading/7-2018-05-24-net-http-part1/</link>
      <pubDate>Thu, 24 May 2018 11:49:10 +0800</pubDate>
      
      <guid>http://bytemode.github.io/reading/7-2018-05-24-net-http-part1/</guid>
      <description>参与人数: 10 人
 Go 标准包阅读
Go 版本：go 1.10.1
net/http  server.go  问题  Next Protocol Negotiation = NPN Expect 100 Continue support   见参考资料
  header提到了：Expect和host 判断了 header里面的HOST，但是后面又删除，为什么？  server.go#L980
delete(req.Header, &amp;#34;Host&amp;#34;)  判断是否支持 HTTP2 （isH2Upgrade）
// isH2Upgrade reports whether r represents the http2 &amp;#34;client preface&amp;#34; // magic string. func (r *Request) isH2Upgrade() bool { return r.Method == &amp;#34;PRI&amp;#34; &amp;amp;&amp;amp; len(r.Header) == 0 &amp;amp;&amp;amp; r.</description>
    </item>
    
    <item>
      <title>第 6 期 2018-05-17 线下活动 - Go 标准包阅读</title>
      <link>http://bytemode.github.io/reading/6-2018-05-17-strings-part4/</link>
      <pubDate>Thu, 17 May 2018 11:49:10 +0800</pubDate>
      
      <guid>http://bytemode.github.io/reading/6-2018-05-17-strings-part4/</guid>
      <description>参与人数: 12 人
 Go 标准包阅读
Go 版本：go 1.10.1
strings  strings.go  问题清单 以下是我们在阅读过程中的一些问题，希望可以引起大家的关注，也欢迎大家提出自己的理解，最好可以给以文章总结。
 // Remove if golang.org/issue/6714 is fixed bp := copy(b, a[0]) return len(s) &amp;gt;= len(prefix) &amp;amp;&amp;amp; s[0:len(prefix)] == prefix 各种开发语言都有的短路机制；字符串底层也是可以用作切片的； 为什么要判断这个错误： if c == utf8.RuneError c -= &amp;lsquo;a&amp;rsquo; - &amp;lsquo;A&amp;rsquo; （小写转大写的算法） // Since we cannot return an error on overflow, // we should panic if the repeat will generate // an overflow. // See Issue golang.</description>
    </item>
    
    <item>
      <title>第 5 期 2018-05-10 线下活动 - Go 标准包阅读</title>
      <link>http://bytemode.github.io/reading/5-2018-05-10-strings-part3/</link>
      <pubDate>Thu, 10 May 2018 11:49:10 +0800</pubDate>
      
      <guid>http://bytemode.github.io/reading/5-2018-05-10-strings-part3/</guid>
      <description>参与人数: 20 人
 Go 标准包阅读
Go 版本：go 1.10.1
strings  strings.go（进度50%）  问题清单 以下是我们在阅读过程中的一些问题，希望可以引起大家的关注，也欢迎大家提出自己的理解，最好可以给以文章总结。
重头戏：Rabin-Karp search
Rabin-Karp 算法的思想：
 假设待匹配字符串的长度为M，目标字符串的长度为N（N&amp;gt;M）； 首先计算待匹配字符串的hash值，计算目标字符串前M个字符的hash值； 比较前面计算的两个hash值，比较次数N-M+1：  若hash值不相等，则继续计算目标字符串的下一个长度为M的字符子串的hash值 若hash值相同，则需要使用朴素算法再次判断是否为相同的字串    16777619 为什么是这个值？ RK, FNV 算法 16777619 = (2^24 + 403)) len 计算问题？是否是每次都会计算，直接拿值，不需要单独计算的；  len(string) 的获取 string 的长度问题：
 涉及到 string 的结构问题。
 在runtime/strings.go 中可以看到对应的 string 结构：
type stringStruct struct { str unsafe.Pointer len int } 可以得到在求 string 的长度的时候，实际上是直接获取值。
在 slice 的结构体中</description>
    </item>
    
    <item>
      <title>第 4 期 2018-04-25 线下活动</title>
      <link>http://bytemode.github.io/reading/4-2018-04-25-strings-part2/</link>
      <pubDate>Wed, 25 Apr 2018 11:49:10 +0800</pubDate>
      
      <guid>http://bytemode.github.io/reading/4-2018-04-25-strings-part2/</guid>
      <description>  参与人数: 15 人
 Go 标准包阅读
Go 版本：go 1.10.1
strings  replace.go replace_test.go search.go search_test.go  问题清单 以下是我们在阅读过程中的一些问题，希望可以引起大家的关注，也欢迎大家提出自己的理解，最好可以给以文章总结。
 Boyer-Moore 算法  延伸阅读  Boyer-Moore_string_search_algorithmde Boyer-Moore字符串搜索算法 字符串匹配的Boyer-Moore算法 grep之字符串搜索算法Boyer-Moore由浅入深（比KMP快3-5倍）  </description>
    </item>
    
    <item>
      <title>第 3 期 2018-04-18 线下活动</title>
      <link>http://bytemode.github.io/reading/3-2018-04-18-strings-part1/</link>
      <pubDate>Wed, 18 Apr 2018 11:49:10 +0800</pubDate>
      
      <guid>http://bytemode.github.io/reading/3-2018-04-18-strings-part1/</guid>
      <description>参与人数: 14 人
 Go 标准包阅读
Go 版本：go 1.10.1
strings  builder.go builder_test.go compare.go compare_test.go example_test.go export_test.go reader_test.go reader.go  问题清单 以下是我们在阅读过程中的一些问题，希望可以引起大家的关注，也欢迎大家提出自己的理解，最好可以给以文章总结。
 defer runtime.GOMAXPROCS(runtime.GOMAXPROCS(1)) runtime.ReadMemStats(&amp;amp;m1) defer_lock.go
package main import ( &amp;#34;sync&amp;#34; ) func main() { var mu sync.Locker = new(I) defer LockUnlock(mu)() println(&amp;#34;doing&amp;#34;) } func LockUnlock(mu sync.Locker) (unlock func()) { mu.Lock() return mu.Unlock } type I struct{} func (i *I) Lock() { println(&amp;#34;lock&amp;#34;) } func (i *I) Unlock() { println(&amp;#34;unlock&amp;#34;) } buf := make([]byte, len(b.</description>
    </item>
    
    <item>
      <title>第 2 期 2018-04-11 线下分享内容</title>
      <link>http://bytemode.github.io/reading/2-2018-04-11-teleport/</link>
      <pubDate>Wed, 11 Apr 2018 11:49:10 +0800</pubDate>
      
      <guid>http://bytemode.github.io/reading/2-2018-04-11-teleport/</guid>
      <description>参与人数: 9 人
微服务相关的开源项目，直接根据 Github 讲解，三个相关的项目链接如下:
  teleport是socket框架 tp-micro是它的扩展，实现了微服务 ants是该微服务的网关、配置中心、代码生成器、部署工具之类的  语音实录  以下内容是分享活动的实录回顾。
  参与人数: 9人 参与者的自我介绍 演示 xiaoneai/ants 分析 tp-micro 和 teleport 框架代码 答疑 确定线下分享形式（标准包和开源项目）  语音实录
语音实录（文字版本 by 录音宝）</description>
    </item>
    
    <item>
      <title>第 1 期 2018-03-21 线下分享内容</title>
      <link>http://bytemode.github.io/reading/1-2018-03-21-goutil/</link>
      <pubDate>Wed, 21 Mar 2018 11:49:10 +0800</pubDate>
      
      <guid>http://bytemode.github.io/reading/1-2018-03-21-goutil/</guid>
      <description>  参与人数: 3 人
 cannot take address of temporary variables 延伸阅读  https://stackoverflow.com/questions/10535743/address-of-a-temporary-in-go https://stackoverflow.com/questions/40926479/take-the-address-of-a-character-in-string https://golang.org/ref/spec#Address_operators  neochain teleport Teleport 是一个通用、高效、灵活的Socket框架。
可用于 Peer-Peer 对等通信、RPC、长连接网关、微服务、推送服务，游戏服务等领域。
goutil 通用的 Go 开发工具包
 Calendar CoarseTime &amp;hellip;  </description>
    </item>
    
  </channel>
</rss>